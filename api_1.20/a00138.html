<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libFirm: Transformations and Optimisations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libFirm&#160;<span id="projectnumber">1.20</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00138.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Transformations and Optimisations</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00126.html">Flags</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Flags to customize the behavior of libfirm. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html">Graph Transformations</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html">Local Optimizations</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga59738bb835a4d0d1388cd6aae5b66974">osr_flag_default</a>&#160;&#160;&#160;osr_flag_lftr_with_ov_check</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">default setting  <a href="#ga59738bb835a4d0d1388cd6aae5b66974"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaa20975b71dbfdf633243725fb1581679">DEFAULT_CLONE_THRESHOLD</a>&#160;&#160;&#160;20</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A default threshold.  <a href="#gaa20975b71dbfdf633243725fb1581679"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga3ad5aab76cb45479207ae4be0352d1a3">check_alloc_entity_func</a> )(<a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *ent)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback that checks whether a entity is an allocation routine.  <a href="#ga3ad5aab76cb45479207ae4be0352d1a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaad391b7bdc7e1fb59586ac8a10d31ab7">arch_allow_ifconv_func</a> )(<a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *sel, <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *mux_false, <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *mux_true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called to evaluate, if a mux(<code>sel</code>, <code>mux_false</code>, <code>mux_true</code>) should be built for the current architecture.  <a href="#gaad391b7bdc7e1fb59586ac8a10d31ab7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga1f9c196513119cc2d6f5fafe2ed472cc">gen_pointer_type_to_func</a> )(<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type for a method, that returns a pointer type to tp.  <a href="#ga1f9c196513119cc2d6f5fafe2ed472cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gafe264e690173189735e67c94f107a80c">opt_ptr</a> )(<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to an optimization function  <a href="#gafe264e690173189735e67c94f107a80c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga21133ed9c9c8e7a8aa78e6421e54d01f">compilerlib_entity_creator_t</a> )(<a class="el" href="a00120.html#ga4bd8b021c0e268b9ff812383a170e3d9">ident</a> *id, <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *mt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of callbacks for createing entities of the compiler library.  <a href="#ga21133ed9c9c8e7a8aa78e6421e54d01f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga53abb9b8cc201d424649b251a8e303b4">osr_flags</a> { <a class="el" href="a00138.html#gga53abb9b8cc201d424649b251a8e303b4a04fdd485155201e8cf1c1b26b2d89cbe">osr_flag_none</a> =  0, 
<a class="el" href="a00138.html#gga53abb9b8cc201d424649b251a8e303b4a71fe499e53732a4008fa4948058657f2">osr_flag_lftr_with_ov_check</a> =  1, 
<a class="el" href="a00138.html#gga53abb9b8cc201d424649b251a8e303b4a9ec9e48928c4edb7165417f3fef80725">osr_flag_ignore_x86_shift</a> =  2, 
<a class="el" href="a00138.html#gga53abb9b8cc201d424649b251a8e303b4aee5709abb0aa671d988a8a31b7b0989a">osr_flag_keep_reg_pressure</a> =  4
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible flags for the Operator Scalar Replacement.  <a href="a00138.html#ga53abb9b8cc201d424649b251a8e303b4">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaf903ed59861491fbbabf628f97ed9047">optimize_cf</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow optimization.  <a href="#gaf903ed59861491fbbabf628f97ed9047"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga6c5351b967040f1fd55c9f53944bfae7">optimize_cf_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#gaf903ed59861491fbbabf628f97ed9047" title="Control flow optimization.">optimize_cf()</a>.  <a href="#ga6c5351b967040f1fd55c9f53944bfae7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gac83b9e1da3ad7b42b056508100a486bd">opt_jumpthreading</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform path-sensitive jump threading on the given graph.  <a href="#gac83b9e1da3ad7b42b056508100a486bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga76b8325ad91a07a39d93fdaac5e085c8">opt_jumpthreading_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#gac83b9e1da3ad7b42b056508100a486bd" title="Perform path-sensitive jump threading on the given graph.">opt_jumpthreading()</a>.  <a href="#ga76b8325ad91a07a39d93fdaac5e085c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga0912d78278d4bbd067d146150a0a246a">opt_bool</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies boolean expression in the given ir graph.  <a href="#ga0912d78278d4bbd067d146150a0a246a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gae6f5bb2763b0d8d5c52127bf71fa85b0">opt_bool_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#ga0912d78278d4bbd067d146150a0a246a" title="Simplifies boolean expression in the given ir graph.">opt_bool()</a>.  <a href="#gae6f5bb2763b0d8d5c52127bf71fa85b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga24a5db5332f90278ad81fcd186e9fcb8">conv_opt</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the number of Conv nodes in the given ir graph.  <a href="#ga24a5db5332f90278ad81fcd186e9fcb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga99219cebbcd59749826f1095cc8d92c2">conv_opt_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#ga24a5db5332f90278ad81fcd186e9fcb8" title="Reduces the number of Conv nodes in the given ir graph.">conv_opt()</a>.  <a href="#ga99219cebbcd59749826f1095cc8d92c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga521acd4d95d1a4195c4290e53d9eebcb">escape_enalysis_irg</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg, <a class="el" href="a00138.html#ga3ad5aab76cb45479207ae4be0352d1a3">check_alloc_entity_func</a> callback)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs simple and fast escape analysis for one graph.  <a href="#ga521acd4d95d1a4195c4290e53d9eebcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga32e1816aba4f02e147d052e920aba75b">escape_analysis</a> (int run_scalar_replace, <a class="el" href="a00138.html#ga3ad5aab76cb45479207ae4be0352d1a3">check_alloc_entity_func</a> callback)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs simple and fast escape analysis for all graphs.  <a href="#ga32e1816aba4f02e147d052e920aba75b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga407e5d3623c2fec8d3cd379ab1dbed40">optimize_funccalls</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize function calls by handling const functions.  <a href="#ga407e5d3623c2fec8d3cd379ab1dbed40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#aa2c8459d7d9f0eeb2a3b13cb18c6de91">ir_prog_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaa2c2a80c4d5ac443760a69493ecd371e">optimize_funccalls_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_prog pass for <a class="el" href="a00138.html#ga407e5d3623c2fec8d3cd379ab1dbed40" title="Optimize function calls by handling const functions.">optimize_funccalls()</a>.  <a href="#gaa2c2a80c4d5ac443760a69493ecd371e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga95391096ce1c40122d400393ea6b3373">do_gvn_pre</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Does Partial Redundancy Elimination combined with Global Value Numbering.  <a href="#ga95391096ce1c40122d400393ea6b3373"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gabcbfec356fe3bb3f6cdf70d943cf8105">do_gvn_pre_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#ga95391096ce1c40122d400393ea6b3373" title="Does Partial Redundancy Elimination combined with Global Value Numbering.">do_gvn_pre()</a>.  <a href="#gabcbfec356fe3bb3f6cdf70d943cf8105"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaad3feb65d42187719d14cdc55f758c11">opt_if_conv</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform If conversion on a graph.  <a href="#gaad3feb65d42187719d14cdc55f758c11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gabd61b54fd69d6993d2de624a8c46a102">opt_if_conv_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#gaad3feb65d42187719d14cdc55f758c11" title="Perform If conversion on a graph.">opt_if_conv()</a>.  <a href="#gabd61b54fd69d6993d2de624a8c46a102"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga0017b31cc79388717a01c16c0c7b463e">opt_parallelize_mem</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to reduce dependencies for memory nodes where possible by parallelizing them and synchronizing with Sync nodes.  <a href="#ga0017b31cc79388717a01c16c0c7b463e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaf9f6eb252d1efa497741308774e06713">opt_parallelize_mem_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for opt_sync().  <a href="#gaf9f6eb252d1efa497741308774e06713"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gacb9c902e7677cb72f54c759d14e6b1b9">can_replace_load_by_const</a> (const <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *load, <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we can replace the load by a given const from the const code irg.  <a href="#gacb9c902e7677cb72f54c759d14e6b1b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gab2cc6fe331da550362a12f385c66fb68">optimize_load_store</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load/Store optimization.  <a href="#gab2cc6fe331da550362a12f385c66fb68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga847d113962186933e7933dc80755fed9">optimize_load_store_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#gab2cc6fe331da550362a12f385c66fb68" title="Load/Store optimization.">optimize_load_store()</a>.  <a href="#ga847d113962186933e7933dc80755fed9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga3cba674ddb026d88f8f2ec2e676f93af">opt_ldst</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">New experimental alternative to optimize_load_store.  <a href="#ga3cba674ddb026d88f8f2ec2e676f93af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga523f775abed92f759f74253e16c8d59e">opt_ldst_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#ga3cba674ddb026d88f8f2ec2e676f93af" title="New experimental alternative to optimize_load_store.">opt_ldst()</a>.  <a href="#ga523f775abed92f759f74253e16c8d59e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga133f5803ec53eec70005924c1330ca7a">loop_optimization</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize loops by peeling or unrolling them if beneficial.  <a href="#ga133f5803ec53eec70005924c1330ca7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga2edb9357b994ddce3ed8f9a80797724e">opt_frame_irg</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize the frame type of an irg by removing never touched entities.  <a href="#ga2edb9357b994ddce3ed8f9a80797724e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga76a79ff646001a342f81510fea4895ee">opt_frame_irg_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#ga2edb9357b994ddce3ed8f9a80797724e" title="Optimize the frame type of an irg by removing never touched entities.">opt_frame_irg()</a>.  <a href="#ga76a79ff646001a342f81510fea4895ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga7d414b64d5b1a085b5ad33e44af6f53e">opt_osr</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg, unsigned flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Operator Scalar Replacement optimization and linear function test replacement for loop control.  <a href="#ga7d414b64d5b1a085b5ad33e44af6f53e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga4280c2040df18ebe00938c48b31d5782">opt_osr_pass</a> (const char *name, unsigned flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#ga756175bf943ce204f24b9370feb1c9da" title="Removes useless Phi cycles, i.e cycles of Phi nodes with only one non-Phi node.">remove_phi_cycles()</a>.  <a href="#ga4280c2040df18ebe00938c48b31d5782"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga756175bf943ce204f24b9370feb1c9da">remove_phi_cycles</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes useless Phi cycles, i.e cycles of Phi nodes with only one non-Phi node.  <a href="#ga756175bf943ce204f24b9370feb1c9da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gacdcd981bb2fc15ec4104d0c3a49f47af">remove_phi_cycles_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#ga756175bf943ce204f24b9370feb1c9da" title="Removes useless Phi cycles, i.e cycles of Phi nodes with only one non-Phi node.">remove_phi_cycles()</a>.  <a href="#gacdcd981bb2fc15ec4104d0c3a49f47af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga1d27ce3f74242e5134ba8939c1f04079">proc_cloning</a> (float threshold)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs procedure cloning.  <a href="#ga1d27ce3f74242e5134ba8939c1f04079"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#aa2c8459d7d9f0eeb2a3b13cb18c6de91">ir_prog_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gabfaf28505930dffc710958b2333cd09e">proc_cloning_pass</a> (const char *name, float threshold)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_prog pass for <a class="el" href="a00138.html#ga1d27ce3f74242e5134ba8939c1f04079" title="Performs procedure cloning.">proc_cloning()</a>.  <a href="#gabfaf28505930dffc710958b2333cd09e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga14293c68c5cd65c4dc35a4509a82780f">optimize_reassociation</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reassociation.  <a href="#ga14293c68c5cd65c4dc35a4509a82780f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaa171e6ddab95547857c6080faafbf4b7">optimize_reassociation_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#ga14293c68c5cd65c4dc35a4509a82780f" title="Reassociation.">optimize_reassociation()</a>.  <a href="#gaa171e6ddab95547857c6080faafbf4b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga23da5562f49a6b93c65c2c2187a124e2">normalize_one_return</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the Returns of a graph by creating a new End block with One Return(Phi).  <a href="#ga23da5562f49a6b93c65c2c2187a124e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gac1b51910c6614ed9fdf3024f09ae4520">normalize_one_return_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#ga23da5562f49a6b93c65c2c2187a124e2" title="Normalize the Returns of a graph by creating a new End block with One Return(Phi).">normalize_one_return()</a>.  <a href="#gac1b51910c6614ed9fdf3024f09ae4520"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga69399d4c6a8a7c789698e73264653145">normalize_n_returns</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the Returns of a graph by moving the Returns upwards as much as possible.  <a href="#ga69399d4c6a8a7c789698e73264653145"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga48b1cc1c9c75f16bca2767272aab5f3a">normalize_n_returns_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#ga69399d4c6a8a7c789698e73264653145" title="Normalize the Returns of a graph by moving the Returns upwards as much as possible.">normalize_n_returns()</a>.  <a href="#ga48b1cc1c9c75f16bca2767272aab5f3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga7aae0c2fbecc4cb130084a7597761bd6">scalar_replacement_opt</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the scalar replacement optimization.  <a href="#ga7aae0c2fbecc4cb130084a7597761bd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga77a262662e6890d8a76bc0e1435fe300">scalar_replacement_opt_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#ga7aae0c2fbecc4cb130084a7597761bd6" title="Performs the scalar replacement optimization.">scalar_replacement_opt()</a>.  <a href="#ga77a262662e6890d8a76bc0e1435fe300"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gab32ab9d5cc9aa0932c631dd464ce4399">opt_tail_rec_irg</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizes tail-recursion calls by converting them into loops.  <a href="#gab32ab9d5cc9aa0932c631dd464ce4399"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga04c217896283b8824a8ab1567c4162ba">opt_tail_rec_irg_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#gab32ab9d5cc9aa0932c631dd464ce4399" title="Optimizes tail-recursion calls by converting them into loops.">opt_tail_rec_irg()</a>.  <a href="#ga04c217896283b8824a8ab1567c4162ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gae00d5d943c331d5ffc5faacf1b0fb462">opt_tail_recursion</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize tail-recursion calls for all IR-Graphs.  <a href="#gae00d5d943c331d5ffc5faacf1b0fb462"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#aa2c8459d7d9f0eeb2a3b13cb18c6de91">ir_prog_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga123be1a92d8287964d61f96ae58d8a2a">opt_tail_recursion_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_prog pass for <a class="el" href="a00138.html#gae00d5d943c331d5ffc5faacf1b0fb462" title="Optimize tail-recursion calls for all IR-Graphs.">opt_tail_recursion()</a>.  <a href="#ga123be1a92d8287964d61f96ae58d8a2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga2c7f8b5583d109f2f5a3575744bf2cdd">normalize_irp_class_casts</a> (<a class="el" href="a00138.html#ga1f9c196513119cc2d6f5fafe2ed472cc">gen_pointer_type_to_func</a> gppt_fct)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert Casts so that class type casts conform exactly with the type hierarchy.  <a href="#ga2c7f8b5583d109f2f5a3575744bf2cdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gafb28c804a5e0932830a89150e94bd3fd">normalize_irg_class_casts</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg, <a class="el" href="a00138.html#ga1f9c196513119cc2d6f5fafe2ed472cc">gen_pointer_type_to_func</a> gppt_fct)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert Casts so that class type casts conform exactly with the type hierarchy in given graph.  <a href="#gafb28c804a5e0932830a89150e94bd3fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga78abb4411c03cfb2421662c4f033e169">optimize_class_casts</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize casting between class types.  <a href="#ga78abb4411c03cfb2421662c4f033e169"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gac32a8900c4aa44431c56d50171e702da">combo</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">CLiff Click's combo algorithm from "Combining Analyses, combining Optimizations".  <a href="#gac32a8900c4aa44431c56d50171e702da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gafa81d6d8780f694b4223df8fa4a25a06">combo_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for combo.  <a href="#gafa81d6d8780f694b4223df8fa4a25a06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga289139df4f7b593229b4f1689537cdc6">inline_small_irgs</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg, int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlines all small methods at call sites where the called address comes from a SymConst node that references the entity representing the called method.  <a href="#ga289139df4f7b593229b4f1689537cdc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gacb7950eae999c8f71488da05d126683e">inline_small_irgs_pass</a> (const char *name, int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#ga289139df4f7b593229b4f1689537cdc6" title="Inlines all small methods at call sites where the called address comes from a SymConst node that refe...">inline_small_irgs()</a>.  <a href="#gacb7950eae999c8f71488da05d126683e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga134676a32ba690c308d2e58a5a3b5a2d">inline_leave_functions</a> (unsigned maxsize, unsigned leavesize, unsigned size, int ignore_runtime)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlineing with a different heuristic than <a class="el" href="a00138.html#ga289139df4f7b593229b4f1689537cdc6" title="Inlines all small methods at call sites where the called address comes from a SymConst node that refe...">inline_small_irgs()</a>.  <a href="#ga134676a32ba690c308d2e58a5a3b5a2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#aa2c8459d7d9f0eeb2a3b13cb18c6de91">ir_prog_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gacbf24d9c1ce2a272de5f509443671e12">inline_leave_functions_pass</a> (const char *name, unsigned maxsize, unsigned leavesize, unsigned size, int ignore_runtime)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_prog pass for <a class="el" href="a00138.html#ga134676a32ba690c308d2e58a5a3b5a2d" title="Inlineing with a different heuristic than inline_small_irgs().">inline_leave_functions()</a>.  <a href="#gacbf24d9c1ce2a272de5f509443671e12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga0ba2ae1263d4d78fc5bdd91b2b6f38b8">inline_functions</a> (unsigned maxsize, int inline_threshold, <a class="el" href="a00138.html#gafe264e690173189735e67c94f107a80c">opt_ptr</a> after_inline_opt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Heuristic inliner.  <a href="#ga0ba2ae1263d4d78fc5bdd91b2b6f38b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#aa2c8459d7d9f0eeb2a3b13cb18c6de91">ir_prog_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga6e83f2b4bf8bcd7c0a9db1856ed44e60">inline_functions_pass</a> (const char *name, unsigned maxsize, int inline_threshold, <a class="el" href="a00138.html#gafe264e690173189735e67c94f107a80c">opt_ptr</a> after_inline_opt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_prog pass for <a class="el" href="a00138.html#ga0ba2ae1263d4d78fc5bdd91b2b6f38b8" title="Heuristic inliner.">inline_functions()</a>.  <a href="#ga6e83f2b4bf8bcd7c0a9db1856ed44e60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga493b2be61c71fec4aff59f5612e07d76">shape_blocks</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines congruent blocks into one.  <a href="#ga493b2be61c71fec4aff59f5612e07d76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaa5a7a8f0491c33ff7683e562750c5478">shape_blocks_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#ga493b2be61c71fec4aff59f5612e07d76" title="Combines congruent blocks into one.">shape_blocks()</a>.  <a href="#gaa5a7a8f0491c33ff7683e562750c5478"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga95271f14cf70188665a0356a3180c459">do_loop_inversion</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform loop inversion on a given graph.  <a href="#ga95271f14cf70188665a0356a3180c459"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gae7e0d72a0309b1a204b7d27707e7c0d1">do_loop_unrolling</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform loop unrolling on a given graph.  <a href="#gae7e0d72a0309b1a204b7d27707e7c0d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga09f81b76d3688ea0c8c18fa96c3f978f">do_loop_peeling</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform loop peeling on a given graph.  <a href="#ga09f81b76d3688ea0c8c18fa96c3f978f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaf05635c9b5c4f539ca672e2b3691764c">loop_inversion_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for loop inversion.  <a href="#gaf05635c9b5c4f539ca672e2b3691764c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gade1c8f1097a4ce866e2973754bd5b7a1">loop_unroll_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for loop unrolling.  <a href="#gade1c8f1097a4ce866e2973754bd5b7a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga13262955cafe372d41dda96b83ed069b">loop_peeling_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for loop peeling.  <a href="#ga13262955cafe372d41dda96b83ed069b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gac128c9f1177304ac18eabd80e11fcef9">set_vrp_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00218.html#gaba3d3c3a783b50e276cb4c481157afbb" title="Sets vrp data on the graph irg.">set_vrp_data()</a>  <a href="#gac128c9f1177304ac18eabd80e11fcef9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga296a2e746af5a301f50ef497634f3645">garbage_collect_entities</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all entities which are unused.  <a href="#ga296a2e746af5a301f50ef497634f3645"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#aa2c8459d7d9f0eeb2a3b13cb18c6de91">ir_prog_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga82c6e8b9fdb69fd9a065d3ffceb66d5e">garbage_collect_entities_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass for garbage_collect_entities.  <a href="#ga82c6e8b9fdb69fd9a065d3ffceb66d5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaea70e1707c7c8fa52482025162908069">dead_node_elimination</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs dead node elimination by copying the ir graph to a new obstack.  <a href="#gaea70e1707c7c8fa52482025162908069"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga48cc5ab0a6b5a49f4d26bedbf4822881">dead_node_elimination_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#gaea70e1707c7c8fa52482025162908069" title="Performs dead node elimination by copying the ir graph to a new obstack.">dead_node_elimination()</a>.  <a href="#ga48cc5ab0a6b5a49f4d26bedbf4822881"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gab61b27d0e1e7892bddab7af340100073">inline_method</a> (<a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *call, <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *called_graph)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlines a method at the given call site.  <a href="#gab61b27d0e1e7892bddab7af340100073"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga0079378f51512c81055cbe916a2514b7">place_code</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Code Placement.  <a href="#ga0079378f51512c81055cbe916a2514b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gae89d211808907b2f3f5a9a1cea90fba0">place_code_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#ga0079378f51512c81055cbe916a2514b7" title="Code Placement.">place_code()</a>.  <a href="#gae89d211808907b2f3f5a9a1cea90fba0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga5606f6cd5edfc2b09cfdb96b594e224f">fixpoint_vrp</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines information about the values of nodes and perform simplifications using this information.  <a href="#ga5606f6cd5edfc2b09cfdb96b594e224f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga877f2b6d57fdd5f9e347a2703c31366d">fixpoint_vrp_irg_pass</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ir_graph pass for <a class="el" href="a00138.html#ga5606f6cd5edfc2b09cfdb96b594e224f" title="Determines information about the values of nodes and perform simplifications using this information...">fixpoint_vrp()</a>.  <a href="#ga877f2b6d57fdd5f9e347a2703c31366d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga3b0b3f93617c9db276b79d895b706e27">value_not_zero</a> (const <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *n, const <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> **confirm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the value of a node is != 0.  <a href="#ga3b0b3f93617c9db276b79d895b706e27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga3b35667fad412939271852a18756c710">value_not_null</a> (const <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *n, const <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> **confirm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the value of a node cannot represent a NULL pointer.  <a href="#ga3b35667fad412939271852a18756c710"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#ad117b2c0857f63eefad71902f5a91ba3">ir_value_classify_sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gac48cb7954ad57919862afd2d6f71c511">classify_value_sign</a> (<a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the value of a node can be confirmed &gt;= 0 or &lt;= 0, If the mode of the value did not honor signed zeros, else check for &gt;= 0 or &lt; 0.  <a href="#gac48cb7954ad57919862afd2d6f71c511"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00200.html#ga264f66b5a3bfcca4dace7f3db21df093">ir_tarval</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga987d9be9d5a4580203dd2ccc444d02b8">computed_value_Cmp_Confirm</a> (const <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *cmp, <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *left, <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *right, <a class="el" href="a00135.html#gaab2daaef197bb78789f904157a4e2695">ir_relation</a> relation)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a Cmp if one or both predecessors are Confirm nodes.  <a href="#ga987d9be9d5a4580203dd2ccc444d02b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga2a2f99efae84cc79f3355b909c034025">set_compilerlib_entity_creator</a> (<a class="el" href="a00138.html#ga21133ed9c9c8e7a8aa78e6421e54d01f">compilerlib_entity_creator_t</a> cb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the compilerlib entity creation callback that is used to create compilerlib function entities.  <a href="#ga2a2f99efae84cc79f3355b909c034025"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00138.html#ga21133ed9c9c8e7a8aa78e6421e54d01f">compilerlib_entity_creator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga497cb3ad7f450a58d9d88715534affa1">get_compilerlib_entity_creator</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the compilerlib entity creation callback.  <a href="#ga497cb3ad7f450a58d9d88715534affa1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gafca06f3cea823ab1ca630070f4e802b7">create_compilerlib_entity</a> (<a class="el" href="a00120.html#ga4bd8b021c0e268b9ff812383a170e3d9">ident</a> *id, <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *mt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the entity for a given function using the current compilerlib entity creation callback.  <a href="#gafca06f3cea823ab1ca630070f4e802b7"></a><br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gaa20975b71dbfdf633243725fb1581679"></a><!-- doxytag: member="iroptimize.h::DEFAULT_CLONE_THRESHOLD" ref="gaa20975b71dbfdf633243725fb1581679" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_CLONE_THRESHOLD&#160;&#160;&#160;20</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A default threshold. </p>

<p>Definition at line <a class="el" href="a00082_source.html#l00456">456</a> of file <a class="el" href="a00082_source.html">iroptimize.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga59738bb835a4d0d1388cd6aae5b66974"></a><!-- doxytag: member="iroptimize.h::osr_flag_default" ref="ga59738bb835a4d0d1388cd6aae5b66974" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define osr_flag_default&#160;&#160;&#160;osr_flag_lftr_with_ov_check</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>default setting </p>

<p>Definition at line <a class="el" href="a00082_source.html#l00361">361</a> of file <a class="el" href="a00082_source.html">iroptimize.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaad391b7bdc7e1fb59586ac8a10d31ab7"></a><!-- doxytag: member="iroptimize.h::arch_allow_ifconv_func" ref="gaad391b7bdc7e1fb59586ac8a10d31ab7" args=")(ir_node *sel, ir_node *mux_false, ir_node *mux_true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="a00138.html#gaad391b7bdc7e1fb59586ac8a10d31ab7">arch_allow_ifconv_func</a>)(<a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *sel, <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *mux_false, <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *mux_true)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is called to evaluate, if a mux(<code>sel</code>, <code>mux_false</code>, <code>mux_true</code>) should be built for the current architecture. </p>
<p>If it returns non-zero, a mux is created, else the code is not modified. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sel</td><td>A selector of a Cond. </td></tr>
    <tr><td class="paramname">phi_list</td><td>phi node to be converted </td></tr>
    <tr><td class="paramname">i</td><td>First data predecessor involved in if conversion </td></tr>
    <tr><td class="paramname">j</td><td>Second data predecessor involved in if conversion </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00082_source.html#l00213">213</a> of file <a class="el" href="a00082_source.html">iroptimize.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3ad5aab76cb45479207ae4be0352d1a3"></a><!-- doxytag: member="iroptimize.h::check_alloc_entity_func" ref="ga3ad5aab76cb45479207ae4be0352d1a3" args=")(ir_entity *ent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="a00138.html#ga3ad5aab76cb45479207ae4be0352d1a3">check_alloc_entity_func</a>)(<a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *ent)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A callback that checks whether a entity is an allocation routine. </p>

<p>Definition at line <a class="el" href="a00082_source.html#l00113">113</a> of file <a class="el" href="a00082_source.html">iroptimize.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga21133ed9c9c8e7a8aa78e6421e54d01f"></a><!-- doxytag: member="iroptimize.h::compilerlib_entity_creator_t" ref="ga21133ed9c9c8e7a8aa78e6421e54d01f" args=")(ident *id, ir_type *mt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a>*(* <a class="el" href="a00138.html#ga21133ed9c9c8e7a8aa78e6421e54d01f">compilerlib_entity_creator_t</a>)(<a class="el" href="a00120.html#ga4bd8b021c0e268b9ff812383a170e3d9">ident</a> *id, <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *mt)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of callbacks for createing entities of the compiler library. </p>

<p>Definition at line <a class="el" href="a00082_source.html#l01080">1080</a> of file <a class="el" href="a00082_source.html">iroptimize.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f9c196513119cc2d6f5fafe2ed472cc"></a><!-- doxytag: member="iroptimize.h::gen_pointer_type_to_func" ref="ga1f9c196513119cc2d6f5fafe2ed472cc" args=")(ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a>*(* <a class="el" href="a00138.html#ga1f9c196513119cc2d6f5fafe2ed472cc">gen_pointer_type_to_func</a>)(<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type for a method, that returns a pointer type to tp. </p>
<p>This is needed in the normalization. </p>

<p>Definition at line <a class="el" href="a00082_source.html#l00641">641</a> of file <a class="el" href="a00082_source.html">iroptimize.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafe264e690173189735e67c94f107a80c"></a><!-- doxytag: member="iroptimize.h::opt_ptr" ref="gafe264e690173189735e67c94f107a80c" args=")(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="a00138.html#gafe264e690173189735e67c94f107a80c">opt_ptr</a>)(<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>pointer to an optimization function </p>

<p>Definition at line <a class="el" href="a00082_source.html#l00799">799</a> of file <a class="el" href="a00082_source.html">iroptimize.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga53abb9b8cc201d424649b251a8e303b4"></a><!-- doxytag: member="iroptimize.h::osr_flags" ref="ga53abb9b8cc201d424649b251a8e303b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00138.html#ga53abb9b8cc201d424649b251a8e303b4">osr_flags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possible flags for the Operator Scalar Replacement. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga53abb9b8cc201d424649b251a8e303b4a04fdd485155201e8cf1c1b26b2d89cbe"></a><!-- doxytag: member="osr_flag_none" ref="gga53abb9b8cc201d424649b251a8e303b4a04fdd485155201e8cf1c1b26b2d89cbe" args="" -->osr_flag_none</em>&nbsp;</td><td>
<p>no additional flags </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga53abb9b8cc201d424649b251a8e303b4a71fe499e53732a4008fa4948058657f2"></a><!-- doxytag: member="osr_flag_lftr_with_ov_check" ref="gga53abb9b8cc201d424649b251a8e303b4a71fe499e53732a4008fa4948058657f2" args="" -->osr_flag_lftr_with_ov_check</em>&nbsp;</td><td>
<p>do linear function test replacement only if no overflow can occur. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga53abb9b8cc201d424649b251a8e303b4a9ec9e48928c4edb7165417f3fef80725"></a><!-- doxytag: member="osr_flag_ignore_x86_shift" ref="gga53abb9b8cc201d424649b251a8e303b4a9ec9e48928c4edb7165417f3fef80725" args="" -->osr_flag_ignore_x86_shift</em>&nbsp;</td><td>
<p>ignore Multiplications by 2, 4, 8 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga53abb9b8cc201d424649b251a8e303b4aee5709abb0aa671d988a8a31b7b0989a"></a><!-- doxytag: member="osr_flag_keep_reg_pressure" ref="gga53abb9b8cc201d424649b251a8e303b4aee5709abb0aa671d988a8a31b7b0989a" args="" -->osr_flag_keep_reg_pressure</em>&nbsp;</td><td>
<p>do NOT increase register pressure by introducing new induction variables. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00082_source.html#l00351">351</a> of file <a class="el" href="a00082_source.html">iroptimize.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gacb9c902e7677cb72f54c759d14e6b1b9"></a><!-- doxytag: member="iroptimize.h::can_replace_load_by_const" ref="gacb9c902e7677cb72f54c759d14e6b1b9" args="(const ir_node *load, ir_node *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a>* can_replace_load_by_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *&#160;</td>
          <td class="paramname"><em>load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if we can replace the load by a given const from the const code irg. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">load</td><td>the load to replace </td></tr>
    <tr><td class="paramname">c</td><td>the constant</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>in the modes match or can be transformed using a reinterpret cast returns a copy of the constant (possibly Conv'ed) on the current_ir_graph </dd></dl>

</div>
</div>
<a class="anchor" id="gac48cb7954ad57919862afd2d6f71c511"></a><!-- doxytag: member="iroptimize.h::classify_value_sign" ref="gac48cb7954ad57919862afd2d6f71c511" args="(ir_node *n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#ad117b2c0857f63eefad71902f5a91ba3">ir_value_classify_sign</a> classify_value_sign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if the value of a node can be confirmed &gt;= 0 or &lt;= 0, If the mode of the value did not honor signed zeros, else check for &gt;= 0 or &lt; 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a node representing the value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac32a8900c4aa44431c56d50171e702da"></a><!-- doxytag: member="iroptimize.h::combo" ref="gac32a8900c4aa44431c56d50171e702da" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void combo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CLiff Click's combo algorithm from "Combining Analyses, combining Optimizations". </p>
<p>Does conditional constant propagation, unreachable code elimination and optimistic global value numbering at once.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>the graph to run on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafa81d6d8780f694b4223df8fa4a25a06"></a><!-- doxytag: member="iroptimize.h::combo_pass" ref="gafa81d6d8780f694b4223df8fa4a25a06" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* combo_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for combo. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga987d9be9d5a4580203dd2ccc444d02b8"></a><!-- doxytag: member="iroptimize.h::computed_value_Cmp_Confirm" ref="ga987d9be9d5a4580203dd2ccc444d02b8" args="(const ir_node *cmp, ir_node *left, ir_node *right, ir_relation relation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00200.html#ga264f66b5a3bfcca4dace7f3db21df093">ir_tarval</a>* computed_value_Cmp_Confirm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00135.html#gaab2daaef197bb78789f904157a4e2695">ir_relation</a>&#160;</td>
          <td class="paramname"><em>relation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the value of a Cmp if one or both predecessors are Confirm nodes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cmp</td><td>the compare node that will be evaluated </td></tr>
    <tr><td class="paramname">left</td><td>the left operand of the Cmp </td></tr>
    <tr><td class="paramname">right</td><td>the right operand of the Cmp </td></tr>
    <tr><td class="paramname">relation</td><td>the compare relation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga24a5db5332f90278ad81fcd186e9fcb8"></a><!-- doxytag: member="iroptimize.h::conv_opt" ref="ga24a5db5332f90278ad81fcd186e9fcb8" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int conv_opt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reduces the number of Conv nodes in the given ir graph. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>the graph</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>non-zero if the optimization could be applied, 0 else </dd></dl>

</div>
</div>
<a class="anchor" id="ga99219cebbcd59749826f1095cc8d92c2"></a><!-- doxytag: member="iroptimize.h::conv_opt_pass" ref="ga99219cebbcd59749826f1095cc8d92c2" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* conv_opt_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#ga24a5db5332f90278ad81fcd186e9fcb8" title="Reduces the number of Conv nodes in the given ir graph.">conv_opt()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="gafca06f3cea823ab1ca630070f4e802b7"></a><!-- doxytag: member="iroptimize.h::create_compilerlib_entity" ref="gafca06f3cea823ab1ca630070f4e802b7" args="(ident *id, ir_type *mt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a>* create_compilerlib_entity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00120.html#ga4bd8b021c0e268b9ff812383a170e3d9">ident</a> *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>mt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs the entity for a given function using the current compilerlib entity creation callback. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the identifier of the compilerlib function </td></tr>
    <tr><td class="paramname">mt</td><td>the method type of the compilerlib function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaea70e1707c7c8fa52482025162908069"></a><!-- doxytag: member="iroptimize.h::dead_node_elimination" ref="gaea70e1707c7c8fa52482025162908069" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dead_node_elimination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs dead node elimination by copying the ir graph to a new obstack. </p>
<p>The major intention of this pass is to free memory occupied by dead nodes and outdated analyzes information. Further this function removes Bad predecessors from Blocks and the corresponding inputs to Phi nodes. This opens optimization potential for other optimizations. Further this phase reduces dead Block&lt;-&gt;Jmp self-cycles to Bad nodes.</p>
<p>Dead_node_elimination is only performed if options `optimize' and `opt_dead_node_elimination' are set. The graph may not be in state phase_building. The outs datastructure is freed, the outs state set to outs_none. Backedge information is conserved. Removes old attributes of nodes. Sets link field to NULL. Callee information must be freed (irg_callee_info_none).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>The graph to be optimized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga48cc5ab0a6b5a49f4d26bedbf4822881"></a><!-- doxytag: member="iroptimize.h::dead_node_elimination_pass" ref="ga48cc5ab0a6b5a49f4d26bedbf4822881" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* dead_node_elimination_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#gaea70e1707c7c8fa52482025162908069" title="Performs dead node elimination by copying the ir graph to a new obstack.">dead_node_elimination()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga95391096ce1c40122d400393ea6b3373"></a><!-- doxytag: member="iroptimize.h::do_gvn_pre" ref="ga95391096ce1c40122d400393ea6b3373" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void do_gvn_pre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does Partial Redundancy Elimination combined with Global Value Numbering. </p>
<p>Can be used to replace <a class="el" href="a00138.html#ga0079378f51512c81055cbe916a2514b7" title="Code Placement.">place_code()</a> completely.</p>
<p>Based on VanDrunen and Hosking 2004.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabcbfec356fe3bb3f6cdf70d943cf8105"></a><!-- doxytag: member="iroptimize.h::do_gvn_pre_pass" ref="gabcbfec356fe3bb3f6cdf70d943cf8105" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* do_gvn_pre_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#ga95391096ce1c40122d400393ea6b3373" title="Does Partial Redundancy Elimination combined with Global Value Numbering.">do_gvn_pre()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga95271f14cf70188665a0356a3180c459"></a><!-- doxytag: member="iroptimize.h::do_loop_inversion" ref="ga95271f14cf70188665a0356a3180c459" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void do_loop_inversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform loop inversion on a given graph. </p>
<p>Loop inversion transforms a head controlled loop (like while(...) {} and for(...) {}) into a foot controlled loop (do {} while(...)). </p>

</div>
</div>
<a class="anchor" id="ga09f81b76d3688ea0c8c18fa96c3f978f"></a><!-- doxytag: member="iroptimize.h::do_loop_peeling" ref="ga09f81b76d3688ea0c8c18fa96c3f978f" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void do_loop_peeling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform loop peeling on a given graph. </p>

</div>
</div>
<a class="anchor" id="gae7e0d72a0309b1a204b7d27707e7c0d1"></a><!-- doxytag: member="iroptimize.h::do_loop_unrolling" ref="gae7e0d72a0309b1a204b7d27707e7c0d1" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void do_loop_unrolling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform loop unrolling on a given graph. </p>
<p>Loop unrolling multiplies the number loop completely by a number found through a heuristic. </p>

</div>
</div>
<a class="anchor" id="ga32e1816aba4f02e147d052e920aba75b"></a><!-- doxytag: member="iroptimize.h::escape_analysis" ref="ga32e1816aba4f02e147d052e920aba75b" args="(int run_scalar_replace, check_alloc_entity_func callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void escape_analysis </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>run_scalar_replace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00138.html#ga3ad5aab76cb45479207ae4be0352d1a3">check_alloc_entity_func</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs simple and fast escape analysis for all graphs. </p>
<p>This optimization implements a simple and fast but inexact escape analysis. Some addresses might be marked as 'escaped' even if they are not. The advantage is a low memory footprint and fast speed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">run_scalar_replace</td><td>if this flag in non-zero, scalar replacement optimization is run on graphs with removed allocation </td></tr>
    <tr><td class="paramname">callback</td><td>a callback function to check whether a given entity is a allocation call</td></tr>
  </table>
  </dd>
</dl>
<p>This optimization removes allocation which are not used (rare) and replace allocation that can be proved dead at the end of the graph which stack variables.</p>
<p>The creation of stack variable allows scalar replacement to be run only on those graphs that have been changed.</p>
<p>This is most effective on Java where no other stack variables exists. </p>

</div>
</div>
<a class="anchor" id="ga521acd4d95d1a4195c4290e53d9eebcb"></a><!-- doxytag: member="iroptimize.h::escape_enalysis_irg" ref="ga521acd4d95d1a4195c4290e53d9eebcb" args="(ir_graph *irg, check_alloc_entity_func callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void escape_enalysis_irg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00138.html#ga3ad5aab76cb45479207ae4be0352d1a3">check_alloc_entity_func</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs simple and fast escape analysis for one graph. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>the graph </td></tr>
    <tr><td class="paramname">callback</td><td>a callback function to check whether a given entity is a allocation call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5606f6cd5edfc2b09cfdb96b594e224f"></a><!-- doxytag: member="iroptimize.h::fixpoint_vrp" ref="ga5606f6cd5edfc2b09cfdb96b594e224f" args="(ir_graph *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fixpoint_vrp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines information about the values of nodes and perform simplifications using this information. </p>
<p>This optimization performs a data-flow analysis to find the minimal fixpoint. </p>

</div>
</div>
<a class="anchor" id="ga877f2b6d57fdd5f9e347a2703c31366d"></a><!-- doxytag: member="iroptimize.h::fixpoint_vrp_irg_pass" ref="ga877f2b6d57fdd5f9e347a2703c31366d" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* fixpoint_vrp_irg_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#ga5606f6cd5edfc2b09cfdb96b594e224f" title="Determines information about the values of nodes and perform simplifications using this information...">fixpoint_vrp()</a>. </p>
<p>This pass dDetermines information about the values of nodes and perform simplifications using this information. This optimization performs a data-flow analysis to find the minimal fixpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga296a2e746af5a301f50ef497634f3645"></a><!-- doxytag: member="iroptimize.h::garbage_collect_entities" ref="ga296a2e746af5a301f50ef497634f3645" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void garbage_collect_entities </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all entities which are unused. </p>
<p>Unused entities have ir_visibility_local and are not used directly or indirectly through entities/code visible outside the compilation unit. This is usually conservative than gc_irgs, but does not respect properties of object-oriented programs. </p>

</div>
</div>
<a class="anchor" id="ga82c6e8b9fdb69fd9a065d3ffceb66d5e"></a><!-- doxytag: member="iroptimize.h::garbage_collect_entities_pass" ref="ga82c6e8b9fdb69fd9a065d3ffceb66d5e" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#aa2c8459d7d9f0eeb2a3b13cb18c6de91">ir_prog_pass_t</a>* garbage_collect_entities_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pass for garbage_collect_entities. </p>

</div>
</div>
<a class="anchor" id="ga497cb3ad7f450a58d9d88715534affa1"></a><!-- doxytag: member="iroptimize.h::get_compilerlib_entity_creator" ref="ga497cb3ad7f450a58d9d88715534affa1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00138.html#ga21133ed9c9c8e7a8aa78e6421e54d01f">compilerlib_entity_creator_t</a> get_compilerlib_entity_creator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the compilerlib entity creation callback. </p>

</div>
</div>
<a class="anchor" id="ga0ba2ae1263d4d78fc5bdd91b2b6f38b8"></a><!-- doxytag: member="iroptimize.h::inline_functions" ref="ga0ba2ae1263d4d78fc5bdd91b2b6f38b8" args="(unsigned maxsize, int inline_threshold, opt_ptr after_inline_opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inline_functions </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inline_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00138.html#gafe264e690173189735e67c94f107a80c">opt_ptr</a>&#160;</td>
          <td class="paramname"><em>after_inline_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Heuristic inliner. </p>
<p>Calculates a benefice value for every call and inlines those calls with a value higher than the threshold.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">maxsize</td><td>Do not inline any calls if a method has more than maxsize firm nodes. It may reach this limit by inlining. </td></tr>
    <tr><td class="paramname">inline_threshold</td><td>inlining threshold </td></tr>
    <tr><td class="paramname">after_inline_opt</td><td>optimizations performed immediately after inlining some calls </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6e83f2b4bf8bcd7c0a9db1856ed44e60"></a><!-- doxytag: member="iroptimize.h::inline_functions_pass" ref="ga6e83f2b4bf8bcd7c0a9db1856ed44e60" args="(const char *name, unsigned maxsize, int inline_threshold, opt_ptr after_inline_opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#aa2c8459d7d9f0eeb2a3b13cb18c6de91">ir_prog_pass_t</a>* inline_functions_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inline_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00138.html#gafe264e690173189735e67c94f107a80c">opt_ptr</a>&#160;</td>
          <td class="paramname"><em>after_inline_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_prog pass for <a class="el" href="a00138.html#ga0ba2ae1263d4d78fc5bdd91b2b6f38b8" title="Heuristic inliner.">inline_functions()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL </td></tr>
    <tr><td class="paramname">maxsize</td><td>Do not inline any calls if a method has more than maxsize firm nodes. It may reach this limit by inlineing. </td></tr>
    <tr><td class="paramname">inline_threshold</td><td>inlining threshold </td></tr>
    <tr><td class="paramname">after_inline_opt</td><td>a function that is called after inlining a procedure. You should run fast local optimisations here which cleanup the graph before further inlining</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_prog pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga134676a32ba690c308d2e58a5a3b5a2d"></a><!-- doxytag: member="iroptimize.h::inline_leave_functions" ref="ga134676a32ba690c308d2e58a5a3b5a2d" args="(unsigned maxsize, unsigned leavesize, unsigned size, int ignore_runtime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inline_leave_functions </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>leavesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ignore_runtime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inlineing with a different heuristic than <a class="el" href="a00138.html#ga289139df4f7b593229b4f1689537cdc6" title="Inlines all small methods at call sites where the called address comes from a SymConst node that refe...">inline_small_irgs()</a>. </p>
<p>Inlines leave functions. If inlining creates new leave function inlines these, too. (If g calls f, and f calls leave h, h is first inlined in f and then f in g.)</p>
<p>Then inlines all small functions (this is not recursive).</p>
<p>For a heuristic this inlining uses firm node counts. It does not count auxiliary nodes as Proj, Tuple, End, Start, Id, Sync. If the ignore_runtime flag is set, calls to functions marked with the mtp_property_runtime property are ignored.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">maxsize</td><td>Do not inline any calls if a method has more than maxsize firm nodes. It may reach this limit by inlining. </td></tr>
    <tr><td class="paramname">leavesize</td><td>Inline leave functions if they have less than leavesize nodes. </td></tr>
    <tr><td class="paramname">size</td><td>Inline all function smaller than size. </td></tr>
    <tr><td class="paramname">ignore_runtime</td><td>count a function only calling runtime functions as leave </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacbf24d9c1ce2a272de5f509443671e12"></a><!-- doxytag: member="iroptimize.h::inline_leave_functions_pass" ref="gacbf24d9c1ce2a272de5f509443671e12" args="(const char *name, unsigned maxsize, unsigned leavesize, unsigned size, int ignore_runtime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#aa2c8459d7d9f0eeb2a3b13cb18c6de91">ir_prog_pass_t</a>* inline_leave_functions_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>leavesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ignore_runtime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_prog pass for <a class="el" href="a00138.html#ga134676a32ba690c308d2e58a5a3b5a2d" title="Inlineing with a different heuristic than inline_small_irgs().">inline_leave_functions()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL </td></tr>
    <tr><td class="paramname">maxsize</td><td>Do not inline any calls if a method has more than maxsize firm nodes. It may reach this limit by inlining. </td></tr>
    <tr><td class="paramname">leavesize</td><td>Inline leave functions if they have less than leavesize nodes. </td></tr>
    <tr><td class="paramname">size</td><td>Inline all function smaller than size. </td></tr>
    <tr><td class="paramname">ignore_runtime</td><td>count a function only calling runtime functions as leave</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_prog pass </dd></dl>

</div>
</div>
<a class="anchor" id="gab61b27d0e1e7892bddab7af340100073"></a><!-- doxytag: member="iroptimize.h::inline_method" ref="gab61b27d0e1e7892bddab7af340100073" args="(ir_node *call, ir_graph *called_graph)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int inline_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>called_graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inlines a method at the given call site. </p>
<p>Removes the call node and splits the basic block the call node belongs to. Inserts a copy of the called graph between these nodes. Assumes that call is a Call node in current_ir_graph and that the type in the Call nodes type attribute is the same as the type of the called graph. Further it assumes that all Phi nodes in a block of current_ir_graph are assembled in a "link" list in the link field of the corresponding block nodes. Further assumes that all Proj nodes are in a "link" list in the nodes producing the tuple. (This is only an optical feature for the graph.) Conserves this feature for the old nodes of the graph. This precondition can be established by a call to collect_phisprojs(), see <a class="el" href="a00070.html" title="Support for ir graph modification.">irgmod.h</a>. As dead_node_elimination this function reduces dead Block&lt;-&gt;Jmp self-cycles to Bad nodes.</p>
<p>Called_graph must be unequal to current_ir_graph. Will not inline if they are equal. Sets visited masterflag in current_ir_graph to the max of the flag in current and called graph. Assumes that both, the called and the calling graph are in state "op_pin_state_pinned". It is recommended to call <a class="el" href="a00128.html#ga3cd73fb8cdd1a0fa53bf0b26c7f75a03" title="Applies local optimizations (see iropt.h) to all nodes in the graph.">local_optimize_graph()</a> after inlining as this function leaves a set of obscure Tuple nodes, e.g. a Proj-Tuple-Jmp combination as control flow operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">call</td><td>the call node that should be inlined </td></tr>
    <tr><td class="paramname">called_graph</td><td>the IR-graph that is called at call</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>zero if method could not be inlined (recursion for instance), non-zero if all went ok </dd></dl>

</div>
</div>
<a class="anchor" id="ga289139df4f7b593229b4f1689537cdc6"></a><!-- doxytag: member="iroptimize.h::inline_small_irgs" ref="ga289139df4f7b593229b4f1689537cdc6" args="(ir_graph *irg, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inline_small_irgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inlines all small methods at call sites where the called address comes from a SymConst node that references the entity representing the called method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>the graph </td></tr>
    <tr><td class="paramname">size</td><td>maximum function size</td></tr>
  </table>
  </dd>
</dl>
<p>The size argument is a rough measure for the code size of the method: Methods where the obstack containing the firm graph is smaller than size are inlined. Further only a limited number of calls are inlined. If the method contains more than 1024 inlineable calls none will be inlined. Inlining is only performed if flags `optimize' and `inlining' are set. The graph may not be in state phase_building. It is recommended to call <a class="el" href="a00128.html#ga3cd73fb8cdd1a0fa53bf0b26c7f75a03" title="Applies local optimizations (see iropt.h) to all nodes in the graph.">local_optimize_graph()</a> after inlining as this function leaves a set of obscure Tuple nodes, e.g. a Proj-Tuple-Jmp combination as control flow operation. </p>

</div>
</div>
<a class="anchor" id="gacb7950eae999c8f71488da05d126683e"></a><!-- doxytag: member="iroptimize.h::inline_small_irgs_pass" ref="gacb7950eae999c8f71488da05d126683e" args="(const char *name, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* inline_small_irgs_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#ga289139df4f7b593229b4f1689537cdc6" title="Inlines all small methods at call sites where the called address comes from a SymConst node that refe...">inline_small_irgs()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL </td></tr>
    <tr><td class="paramname">size</td><td>maximum function size</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="gaf05635c9b5c4f539ca672e2b3691764c"></a><!-- doxytag: member="iroptimize.h::loop_inversion_pass" ref="gaf05635c9b5c4f539ca672e2b3691764c" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* loop_inversion_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for loop inversion. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga133f5803ec53eec70005924c1330ca7a"></a><!-- doxytag: member="iroptimize.h::loop_optimization" ref="ga133f5803ec53eec70005924c1330ca7a" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loop_optimization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optimize loops by peeling or unrolling them if beneficial. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>The graph whose loops will be processed</td></tr>
  </table>
  </dd>
</dl>
<p>This function did not change the graph, only its frame type. The layout state of the frame type will be set to layout_undefined if entities were removed. </p>

</div>
</div>
<a class="anchor" id="ga13262955cafe372d41dda96b83ed069b"></a><!-- doxytag: member="iroptimize.h::loop_peeling_pass" ref="ga13262955cafe372d41dda96b83ed069b" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* loop_peeling_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for loop peeling. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="gade1c8f1097a4ce866e2973754bd5b7a1"></a><!-- doxytag: member="iroptimize.h::loop_unroll_pass" ref="gade1c8f1097a4ce866e2973754bd5b7a1" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* loop_unroll_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for loop unrolling. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="gafb28c804a5e0932830a89150e94bd3fd"></a><!-- doxytag: member="iroptimize.h::normalize_irg_class_casts" ref="gafb28c804a5e0932830a89150e94bd3fd" args="(ir_graph *irg, gen_pointer_type_to_func gppt_fct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void normalize_irg_class_casts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00138.html#ga1f9c196513119cc2d6f5fafe2ed472cc">gen_pointer_type_to_func</a>&#160;</td>
          <td class="paramname"><em>gppt_fct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert Casts so that class type casts conform exactly with the type hierarchy in given graph. </p>
<p>For more details see <a class="el" href="a00138.html#ga2c7f8b5583d109f2f5a3575744bf2cdd" title="Insert Casts so that class type casts conform exactly with the type hierarchy.">normalize_irp_class_casts()</a>.</p>
<p>This transformation requires that type information is computed. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00087.html" title="Data structure to hold type information for nodes.">irtypeinfo.h</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c7f8b5583d109f2f5a3575744bf2cdd"></a><!-- doxytag: member="iroptimize.h::normalize_irp_class_casts" ref="ga2c7f8b5583d109f2f5a3575744bf2cdd" args="(gen_pointer_type_to_func gppt_fct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void normalize_irp_class_casts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00138.html#ga1f9c196513119cc2d6f5fafe2ed472cc">gen_pointer_type_to_func</a>&#160;</td>
          <td class="paramname"><em>gppt_fct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert Casts so that class type casts conform exactly with the type hierarchy. </p>
<p>Formulated in Java, this achieves the following:</p>
<p>For a class hierarchy class A {} class B extends A {} class C extends B {} we transforms a cast (A)new C() to (A)((B)new C()).</p>
<p>The algorithm works for Casts with class types, but also for Casts with all pointer types that point (over several indirections, i.e. ***A) to a class type. Normalizes all graphs. Computes type information (</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00087.html" title="Data structure to hold type information for nodes.">irtypeinfo.h</a>) if not available. Invalidates trout information as new casts are generated.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gppt_fct</td><td>A function that returns a pointer type that points to the type given as argument. If this parameter is NULL, a default function is used that either uses trout information or performs a O(n) search to find an existing pointer type. If it can not find a type, generates a pointer type with mode_P_mach and suffix "cc_ptr_tp". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga69399d4c6a8a7c789698e73264653145"></a><!-- doxytag: member="iroptimize.h::normalize_n_returns" ref="ga69399d4c6a8a7c789698e73264653145" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void normalize_n_returns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize the Returns of a graph by moving the Returns upwards as much as possible. </p>
<p>This might be preferred for code generation.</p>
<p>In pseudocode, it means:</p>
<p>if (a) res = b; else res = c; return res;</p>
<p>is transformed into</p>
<p>if (a) return b; else return c; </p>

</div>
</div>
<a class="anchor" id="ga48b1cc1c9c75f16bca2767272aab5f3a"></a><!-- doxytag: member="iroptimize.h::normalize_n_returns_pass" ref="ga48b1cc1c9c75f16bca2767272aab5f3a" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* normalize_n_returns_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#ga69399d4c6a8a7c789698e73264653145" title="Normalize the Returns of a graph by moving the Returns upwards as much as possible.">normalize_n_returns()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga23da5562f49a6b93c65c2c2187a124e2"></a><!-- doxytag: member="iroptimize.h::normalize_one_return" ref="ga23da5562f49a6b93c65c2c2187a124e2" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void normalize_one_return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize the Returns of a graph by creating a new End block with One Return(Phi). </p>
<p>This is the preferred input for the if-conversion.</p>
<p>In pseudocode, it means:</p>
<p>if (a) return b; else return c;</p>
<p>is transformed into</p>
<p>if (a) res = b; else res = c; return res; </p>

</div>
</div>
<a class="anchor" id="gac1b51910c6614ed9fdf3024f09ae4520"></a><!-- doxytag: member="iroptimize.h::normalize_one_return_pass" ref="gac1b51910c6614ed9fdf3024f09ae4520" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* normalize_one_return_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#ga23da5562f49a6b93c65c2c2187a124e2" title="Normalize the Returns of a graph by creating a new End block with One Return(Phi).">normalize_one_return()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga0912d78278d4bbd067d146150a0a246a"></a><!-- doxytag: member="iroptimize.h::opt_bool" ref="ga0912d78278d4bbd067d146150a0a246a" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opt_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplifies boolean expression in the given ir graph. </p>
<p>eg. x &lt; 5 &amp;&amp; x &lt; 6 becomes x &lt; 5</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae6f5bb2763b0d8d5c52127bf71fa85b0"></a><!-- doxytag: member="iroptimize.h::opt_bool_pass" ref="gae6f5bb2763b0d8d5c52127bf71fa85b0" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* opt_bool_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#ga0912d78278d4bbd067d146150a0a246a" title="Simplifies boolean expression in the given ir graph.">opt_bool()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga2edb9357b994ddce3ed8f9a80797724e"></a><!-- doxytag: member="iroptimize.h::opt_frame_irg" ref="ga2edb9357b994ddce3ed8f9a80797724e" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opt_frame_irg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optimize the frame type of an irg by removing never touched entities. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>The graph whose frame type will be optimized</td></tr>
  </table>
  </dd>
</dl>
<p>This function did not change the graph, only its frame type. The layout state of the frame type will be set to layout_undefined if entities were removed. </p>

</div>
</div>
<a class="anchor" id="ga76a79ff646001a342f81510fea4895ee"></a><!-- doxytag: member="iroptimize.h::opt_frame_irg_pass" ref="ga76a79ff646001a342f81510fea4895ee" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* opt_frame_irg_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#ga2edb9357b994ddce3ed8f9a80797724e" title="Optimize the frame type of an irg by removing never touched entities.">opt_frame_irg()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="gaad3feb65d42187719d14cdc55f758c11"></a><!-- doxytag: member="iroptimize.h::opt_if_conv" ref="gaad3feb65d42187719d14cdc55f758c11" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opt_if_conv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform If conversion on a graph. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>The graph.</td></tr>
  </table>
  </dd>
</dl>
<p>Cannot handle blocks with Bad control predecessors, so call it after control flow optimization. </p>

</div>
</div>
<a class="anchor" id="gabd61b54fd69d6993d2de624a8c46a102"></a><!-- doxytag: member="iroptimize.h::opt_if_conv_pass" ref="gabd61b54fd69d6993d2de624a8c46a102" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* opt_if_conv_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#gaad3feb65d42187719d14cdc55f758c11" title="Perform If conversion on a graph.">opt_if_conv()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="gac83b9e1da3ad7b42b056508100a486bd"></a><!-- doxytag: member="iroptimize.h::opt_jumpthreading" ref="gac83b9e1da3ad7b42b056508100a486bd" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opt_jumpthreading </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform path-sensitive jump threading on the given graph. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga76b8325ad91a07a39d93fdaac5e085c8"></a><!-- doxytag: member="iroptimize.h::opt_jumpthreading_pass" ref="ga76b8325ad91a07a39d93fdaac5e085c8" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* opt_jumpthreading_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#gac83b9e1da3ad7b42b056508100a486bd" title="Perform path-sensitive jump threading on the given graph.">opt_jumpthreading()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga3cba674ddb026d88f8f2ec2e676f93af"></a><!-- doxytag: member="iroptimize.h::opt_ldst" ref="ga3cba674ddb026d88f8f2ec2e676f93af" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opt_ldst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>New experimental alternative to optimize_load_store. </p>
<p>Based on a dataflow analysis, so load/stores are moved out of loops where possible </p>

</div>
</div>
<a class="anchor" id="ga523f775abed92f759f74253e16c8d59e"></a><!-- doxytag: member="iroptimize.h::opt_ldst_pass" ref="ga523f775abed92f759f74253e16c8d59e" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* opt_ldst_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#ga3cba674ddb026d88f8f2ec2e676f93af" title="New experimental alternative to optimize_load_store.">opt_ldst()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d414b64d5b1a085b5ad33e44af6f53e"></a><!-- doxytag: member="iroptimize.h::opt_osr" ref="ga7d414b64d5b1a085b5ad33e44af6f53e" args="(ir_graph *irg, unsigned flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opt_osr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the Operator Scalar Replacement optimization and linear function test replacement for loop control. </p>
<p>Can be switched off using the set_opt_strength_red() flag. In that case, only <a class="el" href="a00138.html#ga756175bf943ce204f24b9370feb1c9da" title="Removes useless Phi cycles, i.e cycles of Phi nodes with only one non-Phi node.">remove_phi_cycles()</a> is executed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>the graph which should be optimized </td></tr>
    <tr><td class="paramname">flags</td><td>set of osr_flags</td></tr>
  </table>
  </dd>
</dl>
<p>The linear function replacement test is controlled by the flags. If the osr_flag_lftr_with_ov_check is set, the replacement is only done if do overflow can occur. Otherwise it is ALWAYS done which might be insecure.</p>
<p>For instance:</p>
<p>for (i = 0; i &lt; 100; ++i)</p>
<p>might be replaced by</p>
<p>for (i = 0; i &lt; 400; i += 4)</p>
<p>But</p>
<p>for (i = 0; i &lt; 0x7FFFFFFF; ++i)</p>
<p>will not be replaced by</p>
<p>for (i = 0; i &lt; 0xFFFFFFFC; i += 4)</p>
<p>because of overflow.</p>
<p>More bad cases:</p>
<p>for (i = 0; i &lt;= 0xF; ++i)</p>
<p>will NOT be transformed into</p>
<p>for (i = 0xFFFFFFF0; i &lt;= 0xFFFFFFFF; ++i)</p>
<p>although here is no direct overflow. The OV occurs when the ++i is executed (and would created an endless loop here!).</p>
<p>For the same reason, a loop</p>
<p>for (i = 0; i &lt;= 9; i += x)</p>
<p>will NOT be transformed because we cannot estimate whether an overflow might happen adding x.</p>
<p>Note that i &lt; a + 400 is also not possible with the current implementation although this might be allowed by other compilers...</p>
<p>Note further that tests for equality can be handled some simpler (but are not implemented yet).</p>
<p>This algorithm destroys the link field of nodes. </p>

</div>
</div>
<a class="anchor" id="ga4280c2040df18ebe00938c48b31d5782"></a><!-- doxytag: member="iroptimize.h::opt_osr_pass" ref="ga4280c2040df18ebe00938c48b31d5782" args="(const char *name, unsigned flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* opt_osr_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#ga756175bf943ce204f24b9370feb1c9da" title="Removes useless Phi cycles, i.e cycles of Phi nodes with only one non-Phi node.">remove_phi_cycles()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL </td></tr>
    <tr><td class="paramname">flags</td><td>set of osr_flags</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga0017b31cc79388717a01c16c0c7b463e"></a><!-- doxytag: member="iroptimize.h::opt_parallelize_mem" ref="ga0017b31cc79388717a01c16c0c7b463e" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opt_parallelize_mem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to reduce dependencies for memory nodes where possible by parallelizing them and synchronizing with Sync nodes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>the graph where memory operations should be parallelized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf9f6eb252d1efa497741308774e06713"></a><!-- doxytag: member="iroptimize.h::opt_parallelize_mem_pass" ref="gaf9f6eb252d1efa497741308774e06713" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* opt_parallelize_mem_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for opt_sync(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="gab32ab9d5cc9aa0932c631dd464ce4399"></a><!-- doxytag: member="iroptimize.h::opt_tail_rec_irg" ref="gab32ab9d5cc9aa0932c631dd464ce4399" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opt_tail_rec_irg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optimizes tail-recursion calls by converting them into loops. </p>
<p>Depends on the flag opt_tail_recursion. Currently supports the following forms:</p>
<ul>
<li>return func();</li>
<li>return x + func();</li>
<li>return func() - x;</li>
<li>return x * func();</li>
<li>return -func();</li>
</ul>
<p>Does not work for Calls that use the exception stuff.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>the graph to be optimized</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>non-zero if the optimization could be applied, 0 else </dd></dl>

</div>
</div>
<a class="anchor" id="ga04c217896283b8824a8ab1567c4162ba"></a><!-- doxytag: member="iroptimize.h::opt_tail_rec_irg_pass" ref="ga04c217896283b8824a8ab1567c4162ba" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* opt_tail_rec_irg_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#gab32ab9d5cc9aa0932c631dd464ce4399" title="Optimizes tail-recursion calls by converting them into loops.">opt_tail_rec_irg()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="gae00d5d943c331d5ffc5faacf1b0fb462"></a><!-- doxytag: member="iroptimize.h::opt_tail_recursion" ref="gae00d5d943c331d5ffc5faacf1b0fb462" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opt_tail_recursion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optimize tail-recursion calls for all IR-Graphs. </p>
<p>Can currently handle:</p>
<ul>
<li>direct return value, i.e. return func().</li>
<li>additive return value, i.e. return x +/- func()</li>
<li>multiplicative return value, i.e. return x * func() or return -func()</li>
</ul>
<p>The current implementation must be run before <a class="el" href="a00138.html#ga407e5d3623c2fec8d3cd379ab1dbed40" title="Optimize function calls by handling const functions.">optimize_funccalls()</a>, because it expects the memory edges pointing to calls, which might be removed by <a class="el" href="a00138.html#ga407e5d3623c2fec8d3cd379ab1dbed40" title="Optimize function calls by handling const functions.">optimize_funccalls()</a>. </p>

</div>
</div>
<a class="anchor" id="ga123be1a92d8287964d61f96ae58d8a2a"></a><!-- doxytag: member="iroptimize.h::opt_tail_recursion_pass" ref="ga123be1a92d8287964d61f96ae58d8a2a" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#aa2c8459d7d9f0eeb2a3b13cb18c6de91">ir_prog_pass_t</a>* opt_tail_recursion_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_prog pass for <a class="el" href="a00138.html#gae00d5d943c331d5ffc5faacf1b0fb462" title="Optimize tail-recursion calls for all IR-Graphs.">opt_tail_recursion()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_prog pass </dd></dl>

</div>
</div>
<a class="anchor" id="gaf903ed59861491fbbabf628f97ed9047"></a><!-- doxytag: member="iroptimize.h::optimize_cf" ref="gaf903ed59861491fbbabf628f97ed9047" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void optimize_cf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Control flow optimization. </p>
<p>Removes empty blocks doing if simplifications and loop simplifications. A block is empty if it contains only a Jmp node and Phi nodes. Merges single entry single exit blocks with their predecessor and propagates dead control flow by calling equivalent_node(). Independent of compiler flag it removes Tuples from cf edges, Bad predecessors from Blocks and Phis, and unnecessary predecessors of End. Destroys backedge information. </p>

</div>
</div>
<a class="anchor" id="ga6c5351b967040f1fd55c9f53944bfae7"></a><!-- doxytag: member="iroptimize.h::optimize_cf_pass" ref="ga6c5351b967040f1fd55c9f53944bfae7" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* optimize_cf_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#gaf903ed59861491fbbabf628f97ed9047" title="Control flow optimization.">optimize_cf()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga78abb4411c03cfb2421662c4f033e169"></a><!-- doxytag: member="iroptimize.h::optimize_class_casts" ref="ga78abb4411c03cfb2421662c4f033e169" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void optimize_class_casts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optimize casting between class types. </p>
<p>class A { m(); } class B extends A { } class C extends B {} Performs the following transformations: C c = (C)(B)(A)(B)new C() --&gt; C c = (C)(B)newC() --&gt; C c = new C() (Optimizing downcasts as A a = (A)(B)(new A()) --&gt; A a = new A() can be suppressed by setting the flag opt_suppress_downcast_optimization. Downcasting A to B might cause an exception. It is not clear whether this is modeled by the Firm Cast node, as it has no exception outputs.); If there is inh_m() that overwrites m() in B: ((A) new B()).m() --&gt; (new B()).inh_m() Phi((A)x, (A)y) --&gt; (A) Phi (x, y) if (A) is an upcast.</p>
<p>Computes type information if not available. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00087.html" title="Data structure to hold type information for nodes.">irtypeinfo.h</a>. Typeinformation is valid after optimization. Invalidates trout information. </dd></dl>

</div>
</div>
<a class="anchor" id="ga407e5d3623c2fec8d3cd379ab1dbed40"></a><!-- doxytag: member="iroptimize.h::optimize_funccalls" ref="ga407e5d3623c2fec8d3cd379ab1dbed40" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void optimize_funccalls </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optimize function calls by handling const functions. </p>
<p>This optimization first detects all "const functions", i.e., IR graphs that neither read nor write memory (and hence did not create exceptions, as these use memory in Firm).</p>
<p>The result of calls to such functions depends only on its arguments, hence those calls are no more pinned.</p>
<p>This is a rather strong criteria, so do not expect that a lot of functions will be found. Moreover, all of them might already be inlined if inlining is activated. Anyway, it might be good for handling builtin's even if the later read/write memory (but we know how).</p>
<p>This optimizations read the irg_const_function property of entities and and sets the irg_const_function property of graphs.</p>
<p>If callee information is valid, we also optimize polymorphic Calls. </p>

</div>
</div>
<a class="anchor" id="gaa2c2a80c4d5ac443760a69493ecd371e"></a><!-- doxytag: member="iroptimize.h::optimize_funccalls_pass" ref="gaa2c2a80c4d5ac443760a69493ecd371e" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#aa2c8459d7d9f0eeb2a3b13cb18c6de91">ir_prog_pass_t</a>* optimize_funccalls_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_prog pass for <a class="el" href="a00138.html#ga407e5d3623c2fec8d3cd379ab1dbed40" title="Optimize function calls by handling const functions.">optimize_funccalls()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_prog pass </dd></dl>

</div>
</div>
<a class="anchor" id="gab2cc6fe331da550362a12f385c66fb68"></a><!-- doxytag: member="iroptimize.h::optimize_load_store" ref="gab2cc6fe331da550362a12f385c66fb68" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int optimize_load_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load/Store optimization. </p>
<p>Removes redundant non-volatile Loads and Stores. May introduce Bad nodes if exceptional control flow is removed. The following cases are optimized:</p>
<p>Load without result: A Load which has only a memory use is removed.</p>
<p>Load after Store: A Load after a Store is removed, if the Load doesn't have an exception handler OR is in the same block as the Store.</p>
<p>Load after Load: A Load after a Load is removed, if the Load doesn't have an exception handler OR is in the same block as the previous Load.</p>
<p>Store before Store: A Store immediately before another Store in the same block is removed, if the Store doesn't have an exception handler.</p>
<p>Store after Load: A Store after a Load is removed, if the Store doesn't have an exception handler.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>non-zero if the optimization could be applied, 0 else </dd></dl>

</div>
</div>
<a class="anchor" id="ga847d113962186933e7933dc80755fed9"></a><!-- doxytag: member="iroptimize.h::optimize_load_store_pass" ref="ga847d113962186933e7933dc80755fed9" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* optimize_load_store_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#gab2cc6fe331da550362a12f385c66fb68" title="Load/Store optimization.">optimize_load_store()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga14293c68c5cd65c4dc35a4509a82780f"></a><!-- doxytag: member="iroptimize.h::optimize_reassociation" ref="ga14293c68c5cd65c4dc35a4509a82780f" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int optimize_reassociation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reassociation. </p>
<p>Applies Reassociation rules to integer expressions. Beware: Works only if integer overflow might be ignored, as for C, Java and for address expression. Works only if Constant folding is activated.</p>
<p>Uses loop information to detect loop-invariant (i.e. contant inside the loop) values.</p>
<p>See Muchnik 12.3.1 Algebraic Simplification and Reassociation of Addressing Expressions.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>non-zero if the optimization could be applied, 0 else </dd></dl>

</div>
</div>
<a class="anchor" id="gaa171e6ddab95547857c6080faafbf4b7"></a><!-- doxytag: member="iroptimize.h::optimize_reassociation_pass" ref="gaa171e6ddab95547857c6080faafbf4b7" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* optimize_reassociation_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#ga14293c68c5cd65c4dc35a4509a82780f" title="Reassociation.">optimize_reassociation()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga0079378f51512c81055cbe916a2514b7"></a><!-- doxytag: member="iroptimize.h::place_code" ref="ga0079378f51512c81055cbe916a2514b7" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void place_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Code Placement. </p>
<p>Pins all floating nodes to a block where they will be executed only if needed. Depends on the flag opt_global_cse. Graph may not be in phase_building. Does not schedule control dead code. Uses dominator information which it computes if the irg is not in state dom_consistent. Destroys the out information as it moves nodes to other blocks. Optimizes Tuples in Control edges.</p>
<p>Call <a class="el" href="a00128.html#ga8edc0cb3ed354c54eaa8f88bf322079a" title="Places an empty basic block on critical control flow edges thereby removing them.">remove_critical_cf_edges()</a> before <a class="el" href="a00138.html#ga0079378f51512c81055cbe916a2514b7" title="Code Placement.">place_code()</a>. This normalizes the control flow graph so that for all operations a basic block exists where they can be optimally placed. </p>

</div>
</div>
<a class="anchor" id="gae89d211808907b2f3f5a9a1cea90fba0"></a><!-- doxytag: member="iroptimize.h::place_code_pass" ref="gae89d211808907b2f3f5a9a1cea90fba0" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* place_code_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#ga0079378f51512c81055cbe916a2514b7" title="Code Placement.">place_code()</a>. </p>
<p>This pass enables GCSE, runs <a class="el" href="a00128.html#ga84953ec57afd698ca30d90605bfffa4c" title="Same functionality as local_opts above, but without framework wrapper.">optimize_graph_df()</a> and finally <a class="el" href="a00138.html#ga0079378f51512c81055cbe916a2514b7" title="Code Placement.">place_code()</a>;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga1d27ce3f74242e5134ba8939c1f04079"></a><!-- doxytag: member="iroptimize.h::proc_cloning" ref="ga1d27ce3f74242e5134ba8939c1f04079" args="(float threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_cloning </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs procedure cloning. </p>
<p>Evaluate a heuristic weight for every Call(..., Const, ...). If the weight is bigger than threshold, clone the entity and fix the calls.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>the threshold for cloning</td></tr>
  </table>
  </dd>
</dl>
<p>The threshold is an estimation of how many instructions are saved when executing a cloned method. If threshold is 0.0, every possible call is cloned. </p>

</div>
</div>
<a class="anchor" id="gabfaf28505930dffc710958b2333cd09e"></a><!-- doxytag: member="iroptimize.h::proc_cloning_pass" ref="gabfaf28505930dffc710958b2333cd09e" args="(const char *name, float threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#aa2c8459d7d9f0eeb2a3b13cb18c6de91">ir_prog_pass_t</a>* proc_cloning_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_prog pass for <a class="el" href="a00138.html#ga1d27ce3f74242e5134ba8939c1f04079" title="Performs procedure cloning.">proc_cloning()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL </td></tr>
    <tr><td class="paramname">threshold</td><td>the threshold for cloning</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_prog pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga756175bf943ce204f24b9370feb1c9da"></a><!-- doxytag: member="iroptimize.h::remove_phi_cycles" ref="ga756175bf943ce204f24b9370feb1c9da" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_phi_cycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes useless Phi cycles, i.e cycles of Phi nodes with only one non-Phi node. </p>
<p>This is automatically done in <a class="el" href="a00138.html#ga7d414b64d5b1a085b5ad33e44af6f53e" title="Performs the Operator Scalar Replacement optimization and linear function test replacement for loop c...">opt_osr()</a>, so there is no need to call it additionally.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>the graph which should be optimized</td></tr>
  </table>
  </dd>
</dl>
<p>This algorithm destroys the link field of nodes. </p>

</div>
</div>
<a class="anchor" id="gacdcd981bb2fc15ec4104d0c3a49f47af"></a><!-- doxytag: member="iroptimize.h::remove_phi_cycles_pass" ref="gacdcd981bb2fc15ec4104d0c3a49f47af" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* remove_phi_cycles_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#ga756175bf943ce204f24b9370feb1c9da" title="Removes useless Phi cycles, i.e cycles of Phi nodes with only one non-Phi node.">remove_phi_cycles()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga7aae0c2fbecc4cb130084a7597761bd6"></a><!-- doxytag: member="iroptimize.h::scalar_replacement_opt" ref="ga7aae0c2fbecc4cb130084a7597761bd6" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int scalar_replacement_opt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the scalar replacement optimization. </p>
<p>Replaces local compound entities (like structures and arrays) with atomic values if possible. Does not handle classes yet.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>the graph which should be optimized</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>non-zero, if at least one entity was replaced </dd></dl>

</div>
</div>
<a class="anchor" id="ga77a262662e6890d8a76bc0e1435fe300"></a><!-- doxytag: member="iroptimize.h::scalar_replacement_opt_pass" ref="ga77a262662e6890d8a76bc0e1435fe300" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* scalar_replacement_opt_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#ga7aae0c2fbecc4cb130084a7597761bd6" title="Performs the scalar replacement optimization.">scalar_replacement_opt()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga2a2f99efae84cc79f3355b909c034025"></a><!-- doxytag: member="iroptimize.h::set_compilerlib_entity_creator" ref="ga2a2f99efae84cc79f3355b909c034025" args="(compilerlib_entity_creator_t cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_compilerlib_entity_creator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00138.html#ga21133ed9c9c8e7a8aa78e6421e54d01f">compilerlib_entity_creator_t</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the compilerlib entity creation callback that is used to create compilerlib function entities. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>the new compilerlib entity creation callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac128c9f1177304ac18eabd80e11fcef9"></a><!-- doxytag: member="iroptimize.h::set_vrp_pass" ref="gac128c9f1177304ac18eabd80e11fcef9" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* set_vrp_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00218.html#gaba3d3c3a783b50e276cb4c481157afbb" title="Sets vrp data on the graph irg.">set_vrp_data()</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga493b2be61c71fec4aff59f5612e07d76"></a><!-- doxytag: member="iroptimize.h::shape_blocks" ref="ga493b2be61c71fec4aff59f5612e07d76" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int shape_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combines congruent blocks into one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irg</td><td>The IR-graph to optimize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>non-zero if the graph was transformed </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5a7a8f0491c33ff7683e562750c5478"></a><!-- doxytag: member="iroptimize.h::shape_blocks_pass" ref="gaa5a7a8f0491c33ff7683e562750c5478" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a614d341461a54c8eb5c354d3f391473f">ir_graph_pass_t</a>* shape_blocks_pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an ir_graph pass for <a class="el" href="a00138.html#ga493b2be61c71fec4aff59f5612e07d76" title="Combines congruent blocks into one.">shape_blocks()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of this pass or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created ir_graph pass </dd></dl>

</div>
</div>
<a class="anchor" id="ga3b35667fad412939271852a18756c710"></a><!-- doxytag: member="iroptimize.h::value_not_null" ref="ga3b35667fad412939271852a18756c710" args="(const ir_node *n, const ir_node **confirm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int value_not_null </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> **&#160;</td>
          <td class="paramname"><em>confirm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if the value of a node cannot represent a NULL pointer. </p>
<ul>
<li>If option sel_based_null_check_elim is enabled, all Sel nodes can be skipped.</li>
<li>A SymConst(entity) is NEVER a NULL pointer</li>
<li>A Const != NULL is NEVER a NULL pointer</li>
<li>Confirms are evaluated</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a node representing the value </td></tr>
    <tr><td class="paramname">confirm</td><td>if n is confirmed to be != NULL, returns the the Confirm-node, else NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b0b3f93617c9db276b79d895b706e27"></a><!-- doxytag: member="iroptimize.h::value_not_zero" ref="ga3b0b3f93617c9db276b79d895b706e27" args="(const ir_node *n, const ir_node **confirm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int value_not_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00135.html#gaa86ae27f3059fdeb9ab036ce326d37f2">ir_node</a> **&#160;</td>
          <td class="paramname"><em>confirm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if the value of a node is != 0. </p>
<p>This is a often needed case, so we handle here Confirm nodes too.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a node representing the value </td></tr>
    <tr><td class="paramname">confirm</td><td>if n is confirmed to be != 0, returns the the Confirm-node, else NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">Generated on Tue Mar 6 2012 16:43:27 for libFirm by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
