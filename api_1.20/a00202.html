<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libFirm: Type System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libFirm&#160;<span id="projectnumber">1.20</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00202.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Type System</div>  </div>
</div>
<div class="contents">

<p>Datastructure to hold type information.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00199.html">Reverse Type Edges</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Trouts list all uses of types and entities. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00203.html">Type Opcodes</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>This module specifies the kinds of types available in firm. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html">Class</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>If the type opcode is set to type_class the type represents class types. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00205.html">Struct</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>A struct type represents aggregate types that consist of a list of fields. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00206.html">Union</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The union type represents union types. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00207.html">Method</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>A method type represents a method, function or procedure type. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00208.html">Array</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The array type represents rectangular multi dimensional arrays. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00209.html">Enumeration</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Enumeration types need not necessarily be represented explicitly by Firm types, as the frontend can lower them to integer constants as well. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00210.html">Pointer</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Pointer types: </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00211.html">Primitive</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Primitive types are types that represent atomic data values that map directly to modes. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00212.html">None</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>This type is an auxiliary type dedicated to support type analyses. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00213.html">Code</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00214.html">Unknown</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>This type is an auxiliary type dedicated to support type analyses. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html">Compound</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00216.html">Frame</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00217.html">Traversing</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga102a4e613c30d7b6f619451eae9c8297">is_SuperClass_of</a>(high, low)&#160;&#160;&#160;is_SubClass_of(low, high)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if high is superclass of low.  <a href="#ga102a4e613c30d7b6f619451eae9c8297"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gaa57268250245581d07202dba4f5dc9e2">is_SuperClass_ptr_of</a>(low, high)&#160;&#160;&#160;is_SubClass_ptr_of(high, low)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Superclass check for pointers to classes.  <a href="#gaa57268250245581d07202dba4f5dc9e2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type.  <a href="#ga5b364a10caee62083a7247148e510de8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00120.html#ga4bd8b021c0e268b9ff812383a170e3d9">ident</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gab69000d0f5a06084bbebad4d0f808260">mangle_inherited_name_func</a> (const <a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *ent, const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *clss)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of argument functions for inheritance resolver.  <a href="#gab69000d0f5a06084bbebad4d0f808260"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gae765957e7685c3dd8a1d4697dbecaf12">inh_transitive_closure_state</a> { <a class="el" href="a00202.html#ggae765957e7685c3dd8a1d4697dbecaf12a6a7ef334de3606b7187cfa25ad0c93fe">inh_transitive_closure_none</a>, 
<a class="el" href="a00202.html#ggae765957e7685c3dd8a1d4697dbecaf12ae0e836561930284a8084489e2faccc5b">inh_transitive_closure_valid</a>, 
<a class="el" href="a00202.html#ggae765957e7685c3dd8a1d4697dbecaf12aa8ce64760a1e477c8b3af843a65dc906">inh_transitive_closure_invalid</a>, 
<a class="el" href="a00202.html#ggae765957e7685c3dd8a1d4697dbecaf12a8dec26412e7d42f71f4fd38d76fba2b9">inh_transitive_closure_max</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The state of the transitive closure.  <a href="a00202.html#gae765957e7685c3dd8a1d4697dbecaf12">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gae9a2d2f4571659572f8891d69780fcd0">ir_class_cast_state</a> { <a class="el" href="a00202.html#ggae9a2d2f4571659572f8891d69780fcd0a340ef099c9152373deb50360058db985">ir_class_casts_any</a> =  0, 
<a class="el" href="a00202.html#ggae9a2d2f4571659572f8891d69780fcd0a3927f7c71d8943a5344a0f19f007fa62">ir_class_casts_transitive</a> =  1, 
<a class="el" href="a00202.html#ggae9a2d2f4571659572f8891d69780fcd0ad5cea95c76bd61c98e47d12707395573">ir_class_casts_normalized</a> =  2, 
<b>ir_class_casts_state_max</b>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The state of Cast operations that cast class types or pointers to class types.  <a href="a00202.html#gae9a2d2f4571659572f8891d69780fcd0">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga8dd8d9e28e3be572022e577bb2a07791">trverify_error_codes</a> { <br/>
&#160;&#160;<a class="el" href="a00202.html#gga8dd8d9e28e3be572022e577bb2a07791a1f1efebf2c41e3bef0fef1862bf5f0c4">no_error</a> =  0, 
<a class="el" href="a00202.html#gga8dd8d9e28e3be572022e577bb2a07791a870a07a20ce52a8e46b5b76bc3597f18">error_ent_not_cont</a>, 
<a class="el" href="a00202.html#gga8dd8d9e28e3be572022e577bb2a07791a33ca15e5b894961c452f9f595bc151e2">error_null_mem</a>, 
<a class="el" href="a00202.html#gga8dd8d9e28e3be572022e577bb2a07791a456af364509aadda6eebc2ec5676faa7">error_const_on_wrong_irg</a>, 
<br/>
&#160;&#160;<a class="el" href="a00202.html#gga8dd8d9e28e3be572022e577bb2a07791a5730a02298d2745ae3ba0672c02359fe">error_existent_entity_without_irg</a>, 
<a class="el" href="a00202.html#gga8dd8d9e28e3be572022e577bb2a07791a4e1d12345ecf753c05f9f2e449038e4f">error_wrong_ent_overwrites</a>, 
<a class="el" href="a00202.html#gga8dd8d9e28e3be572022e577bb2a07791a04804b7b0000f4fae288399c8c9e2343">error_inherited_ent_without_const</a>, 
<a class="el" href="a00202.html#gga8dd8d9e28e3be572022e577bb2a07791ad7a50233f2ea67ad97fac79910c3c100">error_glob_ent_allocation</a>, 
<br/>
&#160;&#160;<a class="el" href="a00202.html#gga8dd8d9e28e3be572022e577bb2a07791aa6ddc55173b4e1943594520e9a332976">error_ent_const_mode</a>, 
<a class="el" href="a00202.html#gga8dd8d9e28e3be572022e577bb2a07791ab6a9e46c46a60c3eea6c8ae1ab6f9ad8">error_ent_wrong_owner</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">possible trverify() error codes  <a href="a00202.html#ga8dd8d9e28e3be572022e577bb2a07791">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gafe39f03b8c3fb57a4c60da910d1bc120">ir_type_state</a> { <a class="el" href="a00202.html#ggafe39f03b8c3fb57a4c60da910d1bc120a11a4d315714c880440ab286fe9614e8a">layout_undefined</a>, 
<a class="el" href="a00202.html#ggafe39f03b8c3fb57a4c60da910d1bc120a5c443acd455eab71dec63eb6af580d4f">layout_fixed</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The state of the type layout.  <a href="a00202.html#gafe39f03b8c3fb57a4c60da910d1bc120">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga5dfe6fa09581607fce69f5a9294771fb">is_SubClass_of</a> (<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *low, <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *high)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if low is subclass of high.  <a href="#ga5dfe6fa09581607fce69f5a9294771fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga2b0b65fe6c45895268a224c9b8f85854">is_SubClass_ptr_of</a> (<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *low, <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *high)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass check for pointers to classes.  <a href="#ga2b0b65fe6c45895268a224c9b8f85854"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga04904040f3a16a740150af3bc1f3b0bb">is_overwritten_by</a> (<a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *high, <a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *low)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if high is (transitive) overwritten by low.  <a href="#ga04904040f3a16a740150af3bc1f3b0bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga9f3926ad411cd320f2154c8089c508a0">resolve_ent_polymorphy</a> (<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *dynamic_class, <a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *static_ent)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve polymorphism in the inheritance relation.  <a href="#ga9f3926ad411cd320f2154c8089c508a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00120.html#ga4bd8b021c0e268b9ff812383a170e3d9">ident</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gad101f6caa066705b15fab7060ae18cbe">default_mangle_inherited_name</a> (const <a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *ent, const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *clss)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default name mangling for inherited entities.  <a href="#gad101f6caa066705b15fab7060ae18cbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gafe8e27b1a2726873a48cd44d5a3305af">resolve_inheritance</a> (<a class="el" href="a00202.html#gab69000d0f5a06084bbebad4d0f808260">mangle_inherited_name_func</a> *mfunc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve implicit inheritance.  <a href="#gafe8e27b1a2726873a48cd44d5a3305af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga16754131c6251ed7edd1a9987e7b7a6b">set_irp_inh_transitive_closure_state</a> (<a class="el" href="a00202.html#gae765957e7685c3dd8a1d4697dbecaf12">inh_transitive_closure_state</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the transitive closure of sub/superclass state for the whole program.  <a href="#ga16754131c6251ed7edd1a9987e7b7a6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gaa2e917b256d82522ee7e6a6d2f80b265">invalidate_irp_inh_transitive_closure_state</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the transitive closure of sub/superclass state for the whole program to <a class="el" href="a00202.html#ggae765957e7685c3dd8a1d4697dbecaf12aa8ce64760a1e477c8b3af843a65dc906" title="Closure invalid, but can be accessed.">inh_transitive_closure_invalid</a>.  <a href="#gaa2e917b256d82522ee7e6a6d2f80b265"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00202.html#gae765957e7685c3dd8a1d4697dbecaf12">inh_transitive_closure_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gaf33fcadb82ce8e270f883b9eb7cac9c0">get_irp_inh_transitive_closure_state</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transitive closure of sub/superclass state for the whole program.  <a href="#gaf33fcadb82ce8e270f883b9eb7cac9c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga27d16383ec081f3a2567924ca1e89af0">compute_inh_transitive_closure</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute transitive closure of the subclass/superclass and overwrites/overwrittenby relation.  <a href="#ga27d16383ec081f3a2567924ca1e89af0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga6a20f7c15b678d852961d0cb4f051f6c">free_inh_transitive_closure</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory occupied by the transitive closure information.  <a href="#ga6a20f7c15b678d852961d0cb4f051f6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gaf9ad15e24c1119767f2809df5ec8b46b">get_class_trans_subtype_first</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start iteration over all transitive subtypes of <code>tp</code>.  <a href="#gaf9ad15e24c1119767f2809df5ec8b46b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga37fc7371e55d337890041294aa592146">get_class_trans_subtype_next</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns next type in a subtype iteration started by <a class="el" href="a00202.html#gaf9ad15e24c1119767f2809df5ec8b46b" title="Start iteration over all transitive subtypes of tp.">get_class_trans_subtype_first()</a>  <a href="#ga37fc7371e55d337890041294aa592146"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga41c0e5b73288078e58f43763b1b3ec7f">is_class_trans_subtype</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp, const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *subtp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>subtp</code> is a subtype of <code>tp</code>.  <a href="#ga41c0e5b73288078e58f43763b1b3ec7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gaffb8e8af7e1d5025cbed23b833e91414">get_class_trans_supertype_first</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start iteration over all transitive supertypes of <code>tp</code>.  <a href="#gaffb8e8af7e1d5025cbed23b833e91414"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga59f32011da7d1ea79084f06ef8cb5fdb">get_class_trans_supertype_next</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns next type in a supertype iteration started by <a class="el" href="a00202.html#gaffb8e8af7e1d5025cbed23b833e91414" title="Start iteration over all transitive supertypes of tp.">get_class_trans_supertype_first()</a>  <a href="#ga59f32011da7d1ea79084f06ef8cb5fdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gaf11e5ccb4184a7bb5ae2dcbacdcf83c8">get_entity_trans_overwrittenby_first</a> (const <a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *ent)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start iteration over all entities that transitive overwrite entity <code>ent</code>.  <a href="#gaf11e5ccb4184a7bb5ae2dcbacdcf83c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga9266a28d085bd93f6071e6b7fec5e971">get_entity_trans_overwrittenby_next</a> (const <a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *ent)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns next entity in a overwrittenby iteration started by <a class="el" href="a00202.html#gaf11e5ccb4184a7bb5ae2dcbacdcf83c8" title="Start iteration over all entities that transitive overwrite entity ent.">get_entity_trans_overwrittenby_first()</a>  <a href="#ga9266a28d085bd93f6071e6b7fec5e971"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gab275dd104b947f651d166ab83df3327e">get_entity_trans_overwrites_first</a> (const <a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *ent)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start iteration over all transitive overwritten entities, overwritten by entity <code>ent</code>.  <a href="#gab275dd104b947f651d166ab83df3327e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gac357442f3d4c844cce8202d25238d21b">get_entity_trans_overwrites_next</a> (const <a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *ent)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns next entity in a overwrites iteration started by <a class="el" href="a00202.html#gab275dd104b947f651d166ab83df3327e" title="Start iteration over all transitive overwritten entities, overwritten by entity ent.">get_entity_trans_overwrites_first()</a>  <a href="#gac357442f3d4c844cce8202d25238d21b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gab52b7d40ebdf51c46583bd6acd99735f">set_irg_class_cast_state</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg, <a class="el" href="a00202.html#gae9a2d2f4571659572f8891d69780fcd0">ir_class_cast_state</a> state)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets class cast state for graph <code>irg</code> to <code>state</code>.  <a href="#gab52b7d40ebdf51c46583bd6acd99735f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00202.html#gae9a2d2f4571659572f8891d69780fcd0">ir_class_cast_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga384bcf7cc88357b7ee0ba91583859849">get_irg_class_cast_state</a> (const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns class cast state for graph <code>irg</code>.  <a href="#ga384bcf7cc88357b7ee0ba91583859849"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga56a8c7b99682f9d71d5e712f6a995148">set_irp_class_cast_state</a> (<a class="el" href="a00202.html#gae9a2d2f4571659572f8891d69780fcd0">ir_class_cast_state</a> state)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets class cast state for the whole program to <code>state</code>.  <a href="#ga56a8c7b99682f9d71d5e712f6a995148"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00202.html#gae9a2d2f4571659572f8891d69780fcd0">ir_class_cast_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga95c141a4ad2e7f472bda23df1db2a3eb">get_irp_class_cast_state</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns class cast state for the whole program.  <a href="#ga95c141a4ad2e7f472bda23df1db2a3eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga99bd5578281bc17470612dc6c9933106">check_type</a> (<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a type.  <a href="#ga99bd5578281bc17470612dc6c9933106"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga644579129332f5be6c17ac058f12b7f7">tr_verify</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Walks the type information and performs a set of sanity checks.  <a href="#ga644579129332f5be6c17ac058f12b7f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gae5eb65b6cd58eb2fc75c8ef059662bbf">free_type</a> (<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the type.  <a href="#gae5eb65b6cd58eb2fc75c8ef059662bbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00203.html#ga1ca2238c85c794bc6c66438028c79de9">tp_op</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga1345b0842a406033bbca43983aac0911">get_type_tpop</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type opcode of type <code>tp</code>.  <a href="#ga1345b0842a406033bbca43983aac0911"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00120.html#ga4bd8b021c0e268b9ff812383a170e3d9">ident</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga78d37dbb4e2268f1ccb8fd20a87e8796">get_type_tpop_nameid</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns name identifier of type opcode of type <code>tp</code>.  <a href="#ga78d37dbb4e2268f1ccb8fd20a87e8796"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga76ded96b35957a281009ad5a0a5585ca">get_type_tpop_name</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns name of type opcode of type <code>tp</code>.  <a href="#ga76ded96b35957a281009ad5a0a5585ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00203.html#ga5e8200f31821cd2b9d48dbe5abd42752">tp_opcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga130cac3cfb8e50dc732f3426f8a1b16d">get_type_tpop_code</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns opcode of type opcode of type <code>tp</code>.  <a href="#ga130cac3cfb8e50dc732f3426f8a1b16d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga484fbb41a6c1b74177a97e414b501220">ir_print_type</a> (char *buffer, size_t buffer_size, const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a string representing the type.  <a href="#ga484fbb41a6c1b74177a97e414b501220"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gad08c97f42d1943b24e0125500f5b1f89">get_type_state_name</a> (<a class="el" href="a00202.html#gafe39f03b8c3fb57a4c60da910d1bc120">ir_type_state</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a human readable string for the enum entry.  <a href="#gad08c97f42d1943b24e0125500f5b1f89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00202.html#gafe39f03b8c3fb57a4c60da910d1bc120">ir_type_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gabd95acf52505f518c1f2c3c84edfe4f9">get_type_state</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type layout state of a type.  <a href="#gabd95acf52505f518c1f2c3c84edfe4f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga5e99b5b80a5860d7e83f5d3117dec68a">set_type_state</a> (<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp, <a class="el" href="a00202.html#gafe39f03b8c3fb57a4c60da910d1bc120">ir_type_state</a> state)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type layout state of a type.  <a href="#ga5e99b5b80a5860d7e83f5d3117dec68a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00134.html#gabb45fd288af194763a5ff0e3666a4b88">ir_mode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga51b342b998da73f43e5bef27330d52bb">get_type_mode</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mode of a type.  <a href="#ga51b342b998da73f43e5bef27330d52bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga3f24db0f65e7e6a0e2fec87b179314b7">set_type_mode</a> (<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp, <a class="el" href="a00134.html#gabb45fd288af194763a5ff0e3666a4b88">ir_mode</a> *m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mode of a type.  <a href="#ga3f24db0f65e7e6a0e2fec87b179314b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gaa1366e1fef982d9ea076d2bc7bd091fc">get_type_size_bytes</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of a type in bytes.  <a href="#gaa1366e1fef982d9ea076d2bc7bd091fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga1b908d9051b44473d990a314454be747">set_type_size_bytes</a> (<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp, unsigned size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of a type in bytes.  <a href="#ga1b908d9051b44473d990a314454be747"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gab96842d6c71c2298ba71f18b5c217b42">get_type_alignment_bytes</a> (<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the alignment of a type in bytes.  <a href="#gab96842d6c71c2298ba71f18b5c217b42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gaab953918c2b268c61844ec3db1566b90">set_type_alignment_bytes</a> (<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp, unsigned align)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the alignment of a type in bytes.  <a href="#gaab953918c2b268c61844ec3db1566b90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a576fff28139c9a6e77001c84d8b57037">ir_visited_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga3ae94fcd0bcf041ebc86534aaad1f3f9">get_type_visited</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the visited counter of a type.  <a href="#ga3ae94fcd0bcf041ebc86534aaad1f3f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga2376e81d9dbc2cd24e989b6b16b3555e">set_type_visited</a> (<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp, <a class="el" href="a00056.html#a576fff28139c9a6e77001c84d8b57037">ir_visited_t</a> num)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the visited counter of a type to num.  <a href="#ga2376e81d9dbc2cd24e989b6b16b3555e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gae8fd748f6d5580ea9d31a1331c4b9177">mark_type_visited</a> (<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets visited field in type to type_visited.  <a href="#gae8fd748f6d5580ea9d31a1331c4b9177"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga2dc2f54709325bd2fc70585dbc7e57ca">type_visited</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the type is already visited.  <a href="#ga2dc2f54709325bd2fc70585dbc7e57ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gaa0f928ed8164834998f8a2fbef6e7947">type_not_visited</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the type is not yet visited.  <a href="#gaa0f928ed8164834998f8a2fbef6e7947"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga3b0c9c9ec8d5a5ce82de359c6de51a9d">get_type_link</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the associated link field of a type.  <a href="#ga3b0c9c9ec8d5a5ce82de359c6de51a9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga447a11d49ffcef322fb1f99802c0d077">set_type_link</a> (<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp, void *l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the associated link field of a type.  <a href="#ga447a11d49ffcef322fb1f99802c0d077"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga8e2925a2e898b464933e34edb1fd64ed">inc_master_type_visited</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments type visited reference counter by one.  <a href="#ga8e2925a2e898b464933e34edb1fd64ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gab73d330c8818a61770cf403b04ce7772">set_master_type_visited</a> (<a class="el" href="a00056.html#a576fff28139c9a6e77001c84d8b57037">ir_visited_t</a> val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets type visited reference counter.  <a href="#gab73d330c8818a61770cf403b04ce7772"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00056.html#a576fff28139c9a6e77001c84d8b57037">ir_visited_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gadd05dbef3a4e4c962d1567123140442d">get_master_type_visited</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type visited reference counter.  <a href="#gadd05dbef3a4e4c962d1567123140442d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gaab3149e6a0a0460f81442777b7bc302b">set_type_dbg_info</a> (<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp, <a class="el" href="a00114.html#ga63247c57676469ec94d1a74f14320014">type_dbg_info</a> *db)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug information of a type.  <a href="#gaab3149e6a0a0460f81442777b7bc302b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00114.html#ga63247c57676469ec94d1a74f14320014">type_dbg_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga838e45ab04c14274ea23acd4f1d431b8">get_type_dbg_info</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug information of a type.  <a href="#ga838e45ab04c14274ea23acd4f1d431b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gac5e0506b5a367bd1ae1556b0210ec752">is_type</a> (const void *thing)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a pointer points to a type.  <a href="#gac5e0506b5a367bd1ae1556b0210ec752"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#gaaa2cff5265585ccae143da7af1f27574">get_type_nr</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a unique number for this type if libfirm is compiled for debugging, (configure with --enable-debug) else returns the address of the type cast to long.  <a href="#gaaa2cff5265585ccae143da7af1f27574"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga4c045fba9dae4c2e5166ca491ae1b610">equal_type</a> (<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *typ1, <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *typ2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two types are structurally equal.  <a href="#ga4c045fba9dae4c2e5166ca491ae1b610"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga725b5125cf6741f70ee34566eb3154f3">smaller_type</a> (<a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *st, <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *lt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two types are structural comparable.  <a href="#ga725b5125cf6741f70ee34566eb3154f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html#ga4cf3ba4c56554c10579c5de11f7a5a2d">is_atomic_type</a> (const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a type is atomic.  <a href="#ga4cf3ba4c56554c10579c5de11f7a5a2d"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Datastructure to hold type information. </p>
<p>This module supplies a datastructure to represent all types known in the compiled program. This includes types specified in the program as well as types defined by the language. In the view of the intermediate representation there is no difference between these types. Finally it specifies some auxiliary types.</p>
<p>There exist several kinds of types, arranged by the structure of the type. A type is described by a set of attributes. Some of these attributes are common to all types, others depend on the kind of the type.</p>
<p>Types are different from the modes defined in irmode: Types are on the level of the programming language, modes at the level of the target processor. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga102a4e613c30d7b6f619451eae9c8297"></a><!-- doxytag: member="typerep.h::is_SuperClass_of" ref="ga102a4e613c30d7b6f619451eae9c8297" args="(high, low)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define is_SuperClass_of</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">high, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">low&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;is_SubClass_of(low, high)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if high is superclass of low. </p>
<p>Low is a subclass of high if low == high or if low is a subclass of a subclass of high. I.e, we search in all subtypes of high for low. @@ this can be implemented more efficient if we know the set of all subclasses of high. </p>

<p>Definition at line <a class="el" href="a00095_source.html#l00851">851</a> of file <a class="el" href="a00095_source.html">typerep.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa57268250245581d07202dba4f5dc9e2"></a><!-- doxytag: member="typerep.h::is_SuperClass_ptr_of" ref="gaa57268250245581d07202dba4f5dc9e2" args="(low, high)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define is_SuperClass_ptr_of</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">low, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">high&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;is_SubClass_ptr_of(high, low)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Superclass check for pointers to classes. </p>
<p>Dereferences at both types the same amount of pointer types (as many as possible). If the remaining types are both class types and superclasses, returns true, else false. Can also be called with two class types. </p>

<p>Definition at line <a class="el" href="a00095_source.html#l00859">859</a> of file <a class="el" href="a00095_source.html">typerep.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga5b364a10caee62083a7247148e510de8"></a><!-- doxytag: member="firm_types.h::ir_type" ref="ga5b364a10caee62083a7247148e510de8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type. </p>

<p>Definition at line <a class="el" href="a00056_source.html#l00084">84</a> of file <a class="el" href="a00056_source.html">firm_types.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab69000d0f5a06084bbebad4d0f808260"></a><!-- doxytag: member="typerep.h::mangle_inherited_name_func" ref="gab69000d0f5a06084bbebad4d0f808260" args="(const ir_entity *ent, const ir_type *clss)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00120.html#ga4bd8b021c0e268b9ff812383a170e3d9">ident</a>* <a class="el" href="a00202.html#gab69000d0f5a06084bbebad4d0f808260">mangle_inherited_name_func</a>(const <a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *ent, const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *clss)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of argument functions for inheritance resolver. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ent</td><td>The entity in the super type that will be overwritten by the newly generated entity, for which this name is used. </td></tr>
    <tr><td class="paramname">clss</td><td>The class type in which the new entity will be placed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00095_source.html#l00888">888</a> of file <a class="el" href="a00095_source.html">typerep.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gae765957e7685c3dd8a1d4697dbecaf12"></a><!-- doxytag: member="typerep.h::inh_transitive_closure_state" ref="gae765957e7685c3dd8a1d4697dbecaf12" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00202.html#gae765957e7685c3dd8a1d4697dbecaf12">inh_transitive_closure_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The state of the transitive closure. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggae765957e7685c3dd8a1d4697dbecaf12a6a7ef334de3606b7187cfa25ad0c93fe"></a><!-- doxytag: member="inh_transitive_closure_none" ref="ggae765957e7685c3dd8a1d4697dbecaf12a6a7ef334de3606b7187cfa25ad0c93fe" args="" -->inh_transitive_closure_none</em>&nbsp;</td><td>
<p>Closure is not computed, can not be accessed. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae765957e7685c3dd8a1d4697dbecaf12ae0e836561930284a8084489e2faccc5b"></a><!-- doxytag: member="inh_transitive_closure_valid" ref="ggae765957e7685c3dd8a1d4697dbecaf12ae0e836561930284a8084489e2faccc5b" args="" -->inh_transitive_closure_valid</em>&nbsp;</td><td>
<p>Closure computed and valid. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae765957e7685c3dd8a1d4697dbecaf12aa8ce64760a1e477c8b3af843a65dc906"></a><!-- doxytag: member="inh_transitive_closure_invalid" ref="ggae765957e7685c3dd8a1d4697dbecaf12aa8ce64760a1e477c8b3af843a65dc906" args="" -->inh_transitive_closure_invalid</em>&nbsp;</td><td>
<p>Closure invalid, but can be accessed. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae765957e7685c3dd8a1d4697dbecaf12a8dec26412e7d42f71f4fd38d76fba2b9"></a><!-- doxytag: member="inh_transitive_closure_max" ref="ggae765957e7685c3dd8a1d4697dbecaf12a8dec26412e7d42f71f4fd38d76fba2b9" args="" -->inh_transitive_closure_max</em>&nbsp;</td><td>
<p>Invalid value. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00095_source.html#l00926">926</a> of file <a class="el" href="a00095_source.html">typerep.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae9a2d2f4571659572f8891d69780fcd0"></a><!-- doxytag: member="typerep.h::ir_class_cast_state" ref="gae9a2d2f4571659572f8891d69780fcd0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00202.html#gae9a2d2f4571659572f8891d69780fcd0">ir_class_cast_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The state of Cast operations that cast class types or pointers to class types. </p>
<p>The state expresses, how far Cast operations conform with the class hierarchy.</p>
<p>class A {} class B1 extends A {} class B2 extends A {} class C extends B1 {} normalized: Cast operations conform with the inheritance relation. I.e., the type of the operand of a Cast is either a super= or a sub- type of the type casted to. Example: (A)((B2) (new C())). transitive: Cast operations conform with the transitive inheritance relation. Example: (A)(new C()). any: Cast operations do not conform with the transitive inheritance relation. Example: (B2)(new B1())</p>
<p>Flags for class cast state.</p>
<p>The state in irp is always smaller or equal to the state of any irg.</p>
<p>We rely on the ordering of the enum. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggae9a2d2f4571659572f8891d69780fcd0a340ef099c9152373deb50360058db985"></a><!-- doxytag: member="ir_class_casts_any" ref="ggae9a2d2f4571659572f8891d69780fcd0a340ef099c9152373deb50360058db985" args="" -->ir_class_casts_any</em>&nbsp;</td><td>
<p>There are class casts that do not cast in conformance with the class hierarchy. </p>
<p>@@ So far this does not happen in Firm. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae9a2d2f4571659572f8891d69780fcd0a3927f7c71d8943a5344a0f19f007fa62"></a><!-- doxytag: member="ir_class_casts_transitive" ref="ggae9a2d2f4571659572f8891d69780fcd0a3927f7c71d8943a5344a0f19f007fa62" args="" -->ir_class_casts_transitive</em>&nbsp;</td><td>
<p>Class casts conform to transitive inheritance edges. </p>
<p>Default. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae9a2d2f4571659572f8891d69780fcd0ad5cea95c76bd61c98e47d12707395573"></a><!-- doxytag: member="ir_class_casts_normalized" ref="ggae9a2d2f4571659572f8891d69780fcd0ad5cea95c76bd61c98e47d12707395573" args="" -->ir_class_casts_normalized</em>&nbsp;</td><td>
<p>Class casts conform to inheritance edges. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00095_source.html#l01017">1017</a> of file <a class="el" href="a00095_source.html">typerep.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafe39f03b8c3fb57a4c60da910d1bc120"></a><!-- doxytag: member="typerep.h::ir_type_state" ref="gafe39f03b8c3fb57a4c60da910d1bc120" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00202.html#gafe39f03b8c3fb57a4c60da910d1bc120">ir_type_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The state of the type layout. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggafe39f03b8c3fb57a4c60da910d1bc120a11a4d315714c880440ab286fe9614e8a"></a><!-- doxytag: member="layout_undefined" ref="ggafe39f03b8c3fb57a4c60da910d1bc120a11a4d315714c880440ab286fe9614e8a" args="" -->layout_undefined</em>&nbsp;</td><td>
<p>The layout of this type is not defined. </p>
<p>Address computation to access fields is not possible, fields must be accessed by Sel nodes. Enumeration constants might be undefined. This is the default value except for pointer, primitive and method types. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafe39f03b8c3fb57a4c60da910d1bc120a5c443acd455eab71dec63eb6af580d4f"></a><!-- doxytag: member="layout_fixed" ref="ggafe39f03b8c3fb57a4c60da910d1bc120a5c443acd455eab71dec63eb6af580d4f" args="" -->layout_fixed</em>&nbsp;</td><td>
<p>The layout is fixed, all component/member entities have an offset assigned. </p>
<p>Size of the type is known. Arrays can be accessed by explicit address computation. Enumeration constants must be defined. Default for pointer, primitive and method types. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00095_source.html#l01103">1103</a> of file <a class="el" href="a00095_source.html">typerep.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga8dd8d9e28e3be572022e577bb2a07791"></a><!-- doxytag: member="typerep.h::trverify_error_codes" ref="ga8dd8d9e28e3be572022e577bb2a07791" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00202.html#ga8dd8d9e28e3be572022e577bb2a07791">trverify_error_codes</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>possible trverify() error codes </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga8dd8d9e28e3be572022e577bb2a07791a1f1efebf2c41e3bef0fef1862bf5f0c4"></a><!-- doxytag: member="no_error" ref="gga8dd8d9e28e3be572022e577bb2a07791a1f1efebf2c41e3bef0fef1862bf5f0c4" args="" -->no_error</em>&nbsp;</td><td>
<p>no error </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8dd8d9e28e3be572022e577bb2a07791a870a07a20ce52a8e46b5b76bc3597f18"></a><!-- doxytag: member="error_ent_not_cont" ref="gga8dd8d9e28e3be572022e577bb2a07791a870a07a20ce52a8e46b5b76bc3597f18" args="" -->error_ent_not_cont</em>&nbsp;</td><td>
<p>overwritten entity not in superclass </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8dd8d9e28e3be572022e577bb2a07791a33ca15e5b894961c452f9f595bc151e2"></a><!-- doxytag: member="error_null_mem" ref="gga8dd8d9e28e3be572022e577bb2a07791a33ca15e5b894961c452f9f595bc151e2" args="" -->error_null_mem</em>&nbsp;</td><td>
<p>compound contains NULL member </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8dd8d9e28e3be572022e577bb2a07791a456af364509aadda6eebc2ec5676faa7"></a><!-- doxytag: member="error_const_on_wrong_irg" ref="gga8dd8d9e28e3be572022e577bb2a07791a456af364509aadda6eebc2ec5676faa7" args="" -->error_const_on_wrong_irg</em>&nbsp;</td><td>
<p>constant placed on wrong IRG </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8dd8d9e28e3be572022e577bb2a07791a5730a02298d2745ae3ba0672c02359fe"></a><!-- doxytag: member="error_existent_entity_without_irg" ref="gga8dd8d9e28e3be572022e577bb2a07791a5730a02298d2745ae3ba0672c02359fe" args="" -->error_existent_entity_without_irg</em>&nbsp;</td><td>
<p>Method entities with pecularity_exist must have an irg. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8dd8d9e28e3be572022e577bb2a07791a4e1d12345ecf753c05f9f2e449038e4f"></a><!-- doxytag: member="error_wrong_ent_overwrites" ref="gga8dd8d9e28e3be572022e577bb2a07791a4e1d12345ecf753c05f9f2e449038e4f" args="" -->error_wrong_ent_overwrites</em>&nbsp;</td><td>
<p>number of entity overwrites exceeds number of class overwrites </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8dd8d9e28e3be572022e577bb2a07791a04804b7b0000f4fae288399c8c9e2343"></a><!-- doxytag: member="error_inherited_ent_without_const" ref="gga8dd8d9e28e3be572022e577bb2a07791a04804b7b0000f4fae288399c8c9e2343" args="" -->error_inherited_ent_without_const</em>&nbsp;</td><td>
<p>inherited method entity not pointing to existent entity </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8dd8d9e28e3be572022e577bb2a07791ad7a50233f2ea67ad97fac79910c3c100"></a><!-- doxytag: member="error_glob_ent_allocation" ref="gga8dd8d9e28e3be572022e577bb2a07791ad7a50233f2ea67ad97fac79910c3c100" args="" -->error_glob_ent_allocation</em>&nbsp;</td><td>
<p>wrong allocation of a global entity </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8dd8d9e28e3be572022e577bb2a07791aa6ddc55173b4e1943594520e9a332976"></a><!-- doxytag: member="error_ent_const_mode" ref="gga8dd8d9e28e3be572022e577bb2a07791aa6ddc55173b4e1943594520e9a332976" args="" -->error_ent_const_mode</em>&nbsp;</td><td>
<p>Mode of constant in entity did not match entities type. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8dd8d9e28e3be572022e577bb2a07791ab6a9e46c46a60c3eea6c8ae1ab6f9ad8"></a><!-- doxytag: member="error_ent_wrong_owner" ref="gga8dd8d9e28e3be572022e577bb2a07791ab6a9e46c46a60c3eea6c8ae1ab6f9ad8" args="" -->error_ent_wrong_owner</em>&nbsp;</td><td>
<p>Mode of constant in entity did not match entities type. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00095_source.html#l01038">1038</a> of file <a class="el" href="a00095_source.html">typerep.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga99bd5578281bc17470612dc6c9933106"></a><!-- doxytag: member="typerep.h::check_type" ref="ga99bd5578281bc17470612dc6c9933106" args="(ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int check_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks a type. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no error encountered </dd></dl>

</div>
</div>
<a class="anchor" id="ga27d16383ec081f3a2567924ca1e89af0"></a><!-- doxytag: member="typerep.h::compute_inh_transitive_closure" ref="ga27d16383ec081f3a2567924ca1e89af0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_inh_transitive_closure </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute transitive closure of the subclass/superclass and overwrites/overwrittenby relation. </p>
<p>This function walks over the ir (O(#types+#entities)) to compute the transitive closure. </p>

</div>
</div>
<a class="anchor" id="gad101f6caa066705b15fab7060ae18cbe"></a><!-- doxytag: member="typerep.h::default_mangle_inherited_name" ref="gad101f6caa066705b15fab7060ae18cbe" args="(const ir_entity *ent, const ir_type *clss)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00120.html#ga4bd8b021c0e268b9ff812383a170e3d9">ident</a>* default_mangle_inherited_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td>
          <td class="paramname"><em>ent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>clss</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default name mangling for inherited entities. </p>
<p>Returns an ident that consists of the name of type followed by an underscore and the name (not ld_name) of the entity. </p>

</div>
</div>
<a class="anchor" id="ga4c045fba9dae4c2e5166ca491ae1b610"></a><!-- doxytag: member="typerep.h::equal_type" ref="ga4c045fba9dae4c2e5166ca491ae1b610" args="(ir_type *typ1, ir_type *typ2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int equal_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>typ1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>typ2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether two types are structurally equal. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">typ1</td><td>the first type </td></tr>
    <tr><td class="paramname">typ2</td><td>the second type</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the types are equal, else false.</dd></dl>
<p>Types are equal if :</p>
<ul>
<li>they are the same type kind</li>
<li>they have the same name</li>
<li>they have the same mode (if applicable)</li>
<li>they have the same type_state and, ev., the same size</li>
<li>they are class types and have:<ul>
<li>the same members (see same_entity in entity.h)</li>
<li>the same supertypes -- the C-pointers are compared --&gt; no recursive call.</li>
<li>the same number of subtypes. Subtypes are not compared, as this could cause a cyclic test.</li>
</ul>
</li>
<li>they are structure types and have the same members</li>
<li>they are method types and have<ul>
<li>the same parameter types</li>
<li>the same result types</li>
</ul>
</li>
<li>they are union types and have the same members</li>
<li>they are array types and have<ul>
<li>the same number of dimensions</li>
<li>the same dimension bounds</li>
<li>the same dimension order</li>
<li>the same element type</li>
</ul>
</li>
<li>they are enumeration types and have the same enumerator names</li>
<li>they are pointer types and have the identical points_to type (i.e., the same C-struct to represent the type. This is to avoid endless recursions; with pointer types cyclic type graphs are possible.) </li>
</ul>

</div>
</div>
<a class="anchor" id="ga6a20f7c15b678d852961d0cb4f051f6c"></a><!-- doxytag: member="typerep.h::free_inh_transitive_closure" ref="ga6a20f7c15b678d852961d0cb4f051f6c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_inh_transitive_closure </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free memory occupied by the transitive closure information. </p>

</div>
</div>
<a class="anchor" id="gae5eb65b6cd58eb2fc75c8ef059662bbf"></a><!-- doxytag: member="typerep.h::free_type" ref="gae5eb65b6cd58eb2fc75c8ef059662bbf" args="(ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees the memory used by the type. </p>
<p>Removes the type from the type list and frees all entities belonging to the type. </p>

</div>
</div>
<a class="anchor" id="gaf9ad15e24c1119767f2809df5ec8b46b"></a><!-- doxytag: member="typerep.h::get_class_trans_subtype_first" ref="gaf9ad15e24c1119767f2809df5ec8b46b" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a>* get_class_trans_subtype_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start iteration over all transitive subtypes of <code>tp</code>. </p>

</div>
</div>
<a class="anchor" id="ga37fc7371e55d337890041294aa592146"></a><!-- doxytag: member="typerep.h::get_class_trans_subtype_next" ref="ga37fc7371e55d337890041294aa592146" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a>* get_class_trans_subtype_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns next type in a subtype iteration started by <a class="el" href="a00202.html#gaf9ad15e24c1119767f2809df5ec8b46b" title="Start iteration over all transitive subtypes of tp.">get_class_trans_subtype_first()</a> </p>

</div>
</div>
<a class="anchor" id="gaffb8e8af7e1d5025cbed23b833e91414"></a><!-- doxytag: member="typerep.h::get_class_trans_supertype_first" ref="gaffb8e8af7e1d5025cbed23b833e91414" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a>* get_class_trans_supertype_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start iteration over all transitive supertypes of <code>tp</code>. </p>

</div>
</div>
<a class="anchor" id="ga59f32011da7d1ea79084f06ef8cb5fdb"></a><!-- doxytag: member="typerep.h::get_class_trans_supertype_next" ref="ga59f32011da7d1ea79084f06ef8cb5fdb" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a>* get_class_trans_supertype_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns next type in a supertype iteration started by <a class="el" href="a00202.html#gaffb8e8af7e1d5025cbed23b833e91414" title="Start iteration over all transitive supertypes of tp.">get_class_trans_supertype_first()</a> </p>

</div>
</div>
<a class="anchor" id="gab275dd104b947f651d166ab83df3327e"></a><!-- doxytag: member="typerep.h::get_entity_trans_overwrites_first" ref="gab275dd104b947f651d166ab83df3327e" args="(const ir_entity *ent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a>* get_entity_trans_overwrites_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td>
          <td class="paramname"><em>ent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start iteration over all transitive overwritten entities, overwritten by entity <code>ent</code>. </p>

</div>
</div>
<a class="anchor" id="gac357442f3d4c844cce8202d25238d21b"></a><!-- doxytag: member="typerep.h::get_entity_trans_overwrites_next" ref="gac357442f3d4c844cce8202d25238d21b" args="(const ir_entity *ent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a>* get_entity_trans_overwrites_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td>
          <td class="paramname"><em>ent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns next entity in a overwrites iteration started by <a class="el" href="a00202.html#gab275dd104b947f651d166ab83df3327e" title="Start iteration over all transitive overwritten entities, overwritten by entity ent.">get_entity_trans_overwrites_first()</a> </p>

</div>
</div>
<a class="anchor" id="gaf11e5ccb4184a7bb5ae2dcbacdcf83c8"></a><!-- doxytag: member="typerep.h::get_entity_trans_overwrittenby_first" ref="gaf11e5ccb4184a7bb5ae2dcbacdcf83c8" args="(const ir_entity *ent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a>* get_entity_trans_overwrittenby_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td>
          <td class="paramname"><em>ent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start iteration over all entities that transitive overwrite entity <code>ent</code>. </p>

</div>
</div>
<a class="anchor" id="ga9266a28d085bd93f6071e6b7fec5e971"></a><!-- doxytag: member="typerep.h::get_entity_trans_overwrittenby_next" ref="ga9266a28d085bd93f6071e6b7fec5e971" args="(const ir_entity *ent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a>* get_entity_trans_overwrittenby_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td>
          <td class="paramname"><em>ent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns next entity in a overwrittenby iteration started by <a class="el" href="a00202.html#gaf11e5ccb4184a7bb5ae2dcbacdcf83c8" title="Start iteration over all entities that transitive overwrite entity ent.">get_entity_trans_overwrittenby_first()</a> </p>

</div>
</div>
<a class="anchor" id="ga384bcf7cc88357b7ee0ba91583859849"></a><!-- doxytag: member="typerep.h::get_irg_class_cast_state" ref="ga384bcf7cc88357b7ee0ba91583859849" args="(const ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00202.html#gae9a2d2f4571659572f8891d69780fcd0">ir_class_cast_state</a> get_irg_class_cast_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns class cast state for graph <code>irg</code>. </p>

</div>
</div>
<a class="anchor" id="ga95c141a4ad2e7f472bda23df1db2a3eb"></a><!-- doxytag: member="typerep.h::get_irp_class_cast_state" ref="ga95c141a4ad2e7f472bda23df1db2a3eb" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00202.html#gae9a2d2f4571659572f8891d69780fcd0">ir_class_cast_state</a> get_irp_class_cast_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns class cast state for the whole program. </p>

</div>
</div>
<a class="anchor" id="gaf33fcadb82ce8e270f883b9eb7cac9c0"></a><!-- doxytag: member="typerep.h::get_irp_inh_transitive_closure_state" ref="gaf33fcadb82ce8e270f883b9eb7cac9c0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00202.html#gae765957e7685c3dd8a1d4697dbecaf12">inh_transitive_closure_state</a> get_irp_inh_transitive_closure_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the transitive closure of sub/superclass state for the whole program. </p>

</div>
</div>
<a class="anchor" id="gadd05dbef3a4e4c962d1567123140442d"></a><!-- doxytag: member="typerep.h::get_master_type_visited" ref="gadd05dbef3a4e4c962d1567123140442d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a576fff28139c9a6e77001c84d8b57037">ir_visited_t</a> get_master_type_visited </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns type visited reference counter. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00002.html">Visited Counters</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab96842d6c71c2298ba71f18b5c217b42"></a><!-- doxytag: member="typerep.h::get_type_alignment_bytes" ref="gab96842d6c71c2298ba71f18b5c217b42" args="(ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned get_type_alignment_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the alignment of a type in bytes. </p>

</div>
</div>
<a class="anchor" id="ga838e45ab04c14274ea23acd4f1d431b8"></a><!-- doxytag: member="typerep.h::get_type_dbg_info" ref="ga838e45ab04c14274ea23acd4f1d431b8" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00114.html#ga63247c57676469ec94d1a74f14320014">type_dbg_info</a>* get_type_dbg_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the debug information of a type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>The type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b0c9c9ec8d5a5ce82de359c6de51a9d"></a><!-- doxytag: member="typerep.h::get_type_link" ref="ga3b0c9c9ec8d5a5ce82de359c6de51a9d" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* get_type_link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the associated link field of a type. </p>

</div>
</div>
<a class="anchor" id="ga51b342b998da73f43e5bef27330d52bb"></a><!-- doxytag: member="typerep.h::get_type_mode" ref="ga51b342b998da73f43e5bef27330d52bb" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00134.html#gabb45fd288af194763a5ff0e3666a4b88">ir_mode</a>* get_type_mode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the mode of a type. </p>
<p>Returns NULL for all non atomic types. </p>

</div>
</div>
<a class="anchor" id="gaaa2cff5265585ccae143da7af1f27574"></a><!-- doxytag: member="typerep.h::get_type_nr" ref="gaaa2cff5265585ccae143da7af1f27574" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long get_type_nr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Outputs a unique number for this type if libfirm is compiled for debugging, (configure with --enable-debug) else returns the address of the type cast to long. </p>

</div>
</div>
<a class="anchor" id="gaa1366e1fef982d9ea076d2bc7bd091fc"></a><!-- doxytag: member="typerep.h::get_type_size_bytes" ref="gaa1366e1fef982d9ea076d2bc7bd091fc" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned get_type_size_bytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of a type in bytes. </p>

</div>
</div>
<a class="anchor" id="gabd95acf52505f518c1f2c3c84edfe4f9"></a><!-- doxytag: member="typerep.h::get_type_state" ref="gabd95acf52505f518c1f2c3c84edfe4f9" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00202.html#gafe39f03b8c3fb57a4c60da910d1bc120">ir_type_state</a> get_type_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the type layout state of a type. </p>

</div>
</div>
<a class="anchor" id="gad08c97f42d1943b24e0125500f5b1f89"></a><!-- doxytag: member="typerep.h::get_type_state_name" ref="gad08c97f42d1943b24e0125500f5b1f89" args="(ir_type_state s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* get_type_state_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#gafe39f03b8c3fb57a4c60da910d1bc120">ir_type_state</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a human readable string for the enum entry. </p>

</div>
</div>
<a class="anchor" id="ga1345b0842a406033bbca43983aac0911"></a><!-- doxytag: member="typerep.h::get_type_tpop" ref="ga1345b0842a406033bbca43983aac0911" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00203.html#ga1ca2238c85c794bc6c66438028c79de9">tp_op</a>* get_type_tpop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns type opcode of type <code>tp</code>. </p>

</div>
</div>
<a class="anchor" id="ga130cac3cfb8e50dc732f3426f8a1b16d"></a><!-- doxytag: member="typerep.h::get_type_tpop_code" ref="ga130cac3cfb8e50dc732f3426f8a1b16d" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00203.html#ga5e8200f31821cd2b9d48dbe5abd42752">tp_opcode</a> get_type_tpop_code </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns opcode of type opcode of type <code>tp</code>. </p>

</div>
</div>
<a class="anchor" id="ga76ded96b35957a281009ad5a0a5585ca"></a><!-- doxytag: member="typerep.h::get_type_tpop_name" ref="ga76ded96b35957a281009ad5a0a5585ca" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* get_type_tpop_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns name of type opcode of type <code>tp</code>. </p>

</div>
</div>
<a class="anchor" id="ga78d37dbb4e2268f1ccb8fd20a87e8796"></a><!-- doxytag: member="typerep.h::get_type_tpop_nameid" ref="ga78d37dbb4e2268f1ccb8fd20a87e8796" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00120.html#ga4bd8b021c0e268b9ff812383a170e3d9">ident</a>* get_type_tpop_nameid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns name identifier of type opcode of type <code>tp</code>. </p>

</div>
</div>
<a class="anchor" id="ga3ae94fcd0bcf041ebc86534aaad1f3f9"></a><!-- doxytag: member="typerep.h::get_type_visited" ref="ga3ae94fcd0bcf041ebc86534aaad1f3f9" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00056.html#a576fff28139c9a6e77001c84d8b57037">ir_visited_t</a> get_type_visited </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the visited counter of a type. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00002.html">Visited Counters</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e2925a2e898b464933e34edb1fd64ed"></a><!-- doxytag: member="typerep.h::inc_master_type_visited" ref="ga8e2925a2e898b464933e34edb1fd64ed" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inc_master_type_visited </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increments type visited reference counter by one. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00002.html">Visited Counters</a>, <a class="el" href="a00202.html#gae8fd748f6d5580ea9d31a1331c4b9177" title="Sets visited field in type to type_visited.">mark_type_visited()</a>, <a class="el" href="a00202.html#ga2dc2f54709325bd2fc70585dbc7e57ca" title="Returns non-zero if the type is already visited.">type_visited()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2e917b256d82522ee7e6a6d2f80b265"></a><!-- doxytag: member="typerep.h::invalidate_irp_inh_transitive_closure_state" ref="gaa2e917b256d82522ee7e6a6d2f80b265" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void invalidate_irp_inh_transitive_closure_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the transitive closure of sub/superclass state for the whole program to <a class="el" href="a00202.html#ggae765957e7685c3dd8a1d4697dbecaf12aa8ce64760a1e477c8b3af843a65dc906" title="Closure invalid, but can be accessed.">inh_transitive_closure_invalid</a>. </p>

</div>
</div>
<a class="anchor" id="ga484fbb41a6c1b74177a97e414b501220"></a><!-- doxytag: member="typerep.h::ir_print_type" ref="ga484fbb41a6c1b74177a97e414b501220" args="(char *buffer, size_t buffer_size, const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ir_print_type </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>construct a string representing the type. </p>
<p>This uses the info retrieved by the type_dbg_info if available. Otherwise it tries to create an approximate textual representation of the type. Keep in mind that this representation is not unique for each type, might abstract away some details. The main intention of this is creating human redable strings giving an idea of the type. </p>

</div>
</div>
<a class="anchor" id="ga4cf3ba4c56554c10579c5de11f7a5a2d"></a><!-- doxytag: member="typerep.h::is_atomic_type" ref="ga4cf3ba4c56554c10579c5de11f7a5a2d" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_atomic_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether a type is atomic. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>any type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if type is primitive, pointer or enumeration </dd></dl>

</div>
</div>
<a class="anchor" id="ga41c0e5b73288078e58f43763b1b3ec7f"></a><!-- doxytag: member="typerep.h::is_class_trans_subtype" ref="ga41c0e5b73288078e58f43763b1b3ec7f" args="(const ir_type *tp, const ir_type *subtp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_class_trans_subtype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>subtp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if <code>subtp</code> is a subtype of <code>tp</code>. </p>
<p>This function checks the full transitive closure of the subtype relation and not just direct subtyping. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if it is a subtype, 0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga04904040f3a16a740150af3bc1f3b0bb"></a><!-- doxytag: member="typerep.h::is_overwritten_by" ref="ga04904040f3a16a740150af3bc1f3b0bb" args="(ir_entity *high, ir_entity *low)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_overwritten_by </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td>
          <td class="paramname"><em>low</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if high is (transitive) overwritten by low. </p>
<p>Returns false if high == low. </p>

</div>
</div>
<a class="anchor" id="ga5dfe6fa09581607fce69f5a9294771fb"></a><!-- doxytag: member="typerep.h::is_SubClass_of" ref="ga5dfe6fa09581607fce69f5a9294771fb" args="(ir_type *low, ir_type *high)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_SubClass_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if low is subclass of high. </p>
<p>Low is a subclass of high if low == high or if low is a subclass of a subclass of high. I.e, we search in all subtypes of high for low. @@ this can be implemented more efficient if we know the set of all subclasses of high. </p>

</div>
</div>
<a class="anchor" id="ga2b0b65fe6c45895268a224c9b8f85854"></a><!-- doxytag: member="typerep.h::is_SubClass_ptr_of" ref="ga2b0b65fe6c45895268a224c9b8f85854" args="(ir_type *low, ir_type *high)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_SubClass_ptr_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subclass check for pointers to classes. </p>
<p>Dereferences at both types the same amount of pointer types (as many as possible). If the remaining types are both class types and subclasses, returns true, else false. Can also be called with two class types. </p>

</div>
</div>
<a class="anchor" id="gac5e0506b5a367bd1ae1556b0210ec752"></a><!-- doxytag: member="typerep.h::is_type" ref="gac5e0506b5a367bd1ae1556b0210ec752" args="(const void *thing)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_type </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>thing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether a pointer points to a type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thing</td><td>an arbitrary pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the thing is a type, else false </dd></dl>

</div>
</div>
<a class="anchor" id="gae8fd748f6d5580ea9d31a1331c4b9177"></a><!-- doxytag: member="typerep.h::mark_type_visited" ref="gae8fd748f6d5580ea9d31a1331c4b9177" args="(ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mark_type_visited </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets visited field in type to type_visited. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00002.html">Visited Counters</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f3926ad411cd320f2154c8089c508a0"></a><!-- doxytag: member="typerep.h::resolve_ent_polymorphy" ref="ga9f3926ad411cd320f2154c8089c508a0" args="(ir_type *dynamic_class, ir_entity *static_ent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a>* resolve_ent_polymorphy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>dynamic_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td>
          <td class="paramname"><em>static_ent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resolve polymorphism in the inheritance relation. </p>
<p>Returns the dynamically referenced entity if the static entity and the dynamic type are given. Searches downwards in overwritten tree. </p>

</div>
</div>
<a class="anchor" id="gafe8e27b1a2726873a48cd44d5a3305af"></a><!-- doxytag: member="typerep.h::resolve_inheritance" ref="gafe8e27b1a2726873a48cd44d5a3305af" args="(mangle_inherited_name_func *mfunc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void resolve_inheritance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#gab69000d0f5a06084bbebad4d0f808260">mangle_inherited_name_func</a> *&#160;</td>
          <td class="paramname"><em>mfunc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resolve implicit inheritance. </p>
<p>Resolves the implicit inheritance supplied by firm. Firm defines, that each entity that is not overwritten in a subclass is inherited to this subclass without change implicitly. This function generates entities that explicitly represent this inheritance. It generates for each entity overwriting entities in all subclasses of the owner of the entity, if the entity is not overwritten in that subclass.</p>
<p>The name of the new entity is generated with the function passed. If the function is NULL, the <a class="el" href="a00202.html#gad101f6caa066705b15fab7060ae18cbe" title="Default name mangling for inherited entities.">default_mangle_inherited_name()</a> is used. </p>

</div>
</div>
<a class="anchor" id="gab52b7d40ebdf51c46583bd6acd99735f"></a><!-- doxytag: member="typerep.h::set_irg_class_cast_state" ref="gab52b7d40ebdf51c46583bd6acd99735f" args="(ir_graph *irg, ir_class_cast_state state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_irg_class_cast_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00202.html#gae9a2d2f4571659572f8891d69780fcd0">ir_class_cast_state</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets class cast state for graph <code>irg</code> to <code>state</code>. </p>

</div>
</div>
<a class="anchor" id="ga56a8c7b99682f9d71d5e712f6a995148"></a><!-- doxytag: member="typerep.h::set_irp_class_cast_state" ref="ga56a8c7b99682f9d71d5e712f6a995148" args="(ir_class_cast_state state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_irp_class_cast_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#gae9a2d2f4571659572f8891d69780fcd0">ir_class_cast_state</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets class cast state for the whole program to <code>state</code>. </p>

</div>
</div>
<a class="anchor" id="ga16754131c6251ed7edd1a9987e7b7a6b"></a><!-- doxytag: member="typerep.h::set_irp_inh_transitive_closure_state" ref="ga16754131c6251ed7edd1a9987e7b7a6b" args="(inh_transitive_closure_state s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_irp_inh_transitive_closure_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#gae765957e7685c3dd8a1d4697dbecaf12">inh_transitive_closure_state</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the transitive closure of sub/superclass state for the whole program. </p>

</div>
</div>
<a class="anchor" id="gab73d330c8818a61770cf403b04ce7772"></a><!-- doxytag: member="typerep.h::set_master_type_visited" ref="gab73d330c8818a61770cf403b04ce7772" args="(ir_visited_t val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_master_type_visited </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00056.html#a576fff28139c9a6e77001c84d8b57037">ir_visited_t</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets type visited reference counter. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00002.html">Visited Counters</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaab953918c2b268c61844ec3db1566b90"></a><!-- doxytag: member="typerep.h::set_type_alignment_bytes" ref="gaab953918c2b268c61844ec3db1566b90" args="(ir_type *tp, unsigned align)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_type_alignment_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the alignment of a type in bytes. </p>
<p>If the alignment of a type is not set, it is calculated here according to the following rules: -#.) if a type has a mode, the alignment is the mode size. -#.) compound types have the alignment of their biggest member. -#.) array types have the alignment of their element type. -#.) method types return 0 here. -#.) all other types return 1 here (i.e. aligned at byte). </p>

</div>
</div>
<a class="anchor" id="gaab3149e6a0a0460f81442777b7bc302b"></a><!-- doxytag: member="typerep.h::set_type_dbg_info" ref="gaab3149e6a0a0460f81442777b7bc302b" args="(ir_type *tp, type_dbg_info *db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_type_dbg_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00114.html#ga63247c57676469ec94d1a74f14320014">type_dbg_info</a> *&#160;</td>
          <td class="paramname"><em>db</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the debug information of a type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>The type. </td></tr>
    <tr><td class="paramname">db</td><td>The debug info. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga447a11d49ffcef322fb1f99802c0d077"></a><!-- doxytag: member="typerep.h::set_type_link" ref="ga447a11d49ffcef322fb1f99802c0d077" args="(ir_type *tp, void *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_type_link </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the associated link field of a type. </p>

</div>
</div>
<a class="anchor" id="ga3f24db0f65e7e6a0e2fec87b179314b7"></a><!-- doxytag: member="typerep.h::set_type_mode" ref="ga3f24db0f65e7e6a0e2fec87b179314b7" args="(ir_type *tp, ir_mode *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_type_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00134.html#gabb45fd288af194763a5ff0e3666a4b88">ir_mode</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the mode of a type. </p>
<p>Only has an effect on primitive, enumeration and pointer types. </p>

</div>
</div>
<a class="anchor" id="ga1b908d9051b44473d990a314454be747"></a><!-- doxytag: member="typerep.h::set_type_size_bytes" ref="ga1b908d9051b44473d990a314454be747" args="(ir_type *tp, unsigned size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_type_size_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the size of a type in bytes. </p>
<p>For primitive, enumeration, pointer and method types the size is always fixed. This call is legal but has no effect. </p>

</div>
</div>
<a class="anchor" id="ga5e99b5b80a5860d7e83f5d3117dec68a"></a><!-- doxytag: member="typerep.h::set_type_state" ref="ga5e99b5b80a5860d7e83f5d3117dec68a" args="(ir_type *tp, ir_type_state state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_type_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00202.html#gafe39f03b8c3fb57a4c60da910d1bc120">ir_type_state</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the type layout state of a type. </p>
<p>For primitives, pointer and method types the layout is always fixed. This call is legal but has no effect. </p>

</div>
</div>
<a class="anchor" id="ga2376e81d9dbc2cd24e989b6b16b3555e"></a><!-- doxytag: member="typerep.h::set_type_visited" ref="ga2376e81d9dbc2cd24e989b6b16b3555e" args="(ir_type *tp, ir_visited_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_type_visited </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00056.html#a576fff28139c9a6e77001c84d8b57037">ir_visited_t</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the visited counter of a type to num. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00002.html">Visited Counters</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga725b5125cf6741f70ee34566eb3154f3"></a><!-- doxytag: member="typerep.h::smaller_type" ref="ga725b5125cf6741f70ee34566eb3154f3" args="(ir_type *st, ir_type *lt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smaller_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>lt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether two types are structural comparable. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>pointer type </td></tr>
    <tr><td class="paramname">lt</td><td>pointer type</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if type st is smaller than type lt, i.e. whenever lt is expected a st can be used. This is true if<ul>
<li>they are the same type kind</li>
<li>mode(st) &lt; mode (lt) (if applicable)</li>
<li>they are class types and st is (transitive) subtype of lt,</li>
<li>they are structure types and<ul>
<li>the members of st have exactly one counterpart in lt with the same name,</li>
<li>the counterpart has a bigger type.</li>
</ul>
</li>
<li>they are method types and have<ul>
<li>the same number of parameter and result types,</li>
<li>the parameter types of st are smaller than those of lt,</li>
<li>the result types of st are smaller than those of lt</li>
</ul>
</li>
<li>they are union types and have the members of st have exactly one </li>
</ul>
</dd>
<dd>
counterpart in lt and the type is smaller<ul>
<li>they are array types and have<ul>
<li>the same number of dimensions</li>
<li>all bounds of lt are bound of st</li>
<li>the same dimension order</li>
<li>the same element type </li>
</ul>
</li>
</ul>
</dd>
<dd>
or<ul>
<li>the element type of st is smaller than that of lt</li>
<li>the element types have the same size and fixed layout.</li>
</ul>
</dd></dl>
<ul>
<li>they are enumeration types and have the same enumerator names</li>
<li>they are pointer types and have the points_to type of st is <dl class="return"><dt><b>Returns:</b></dt><dd>smaller than the points_to type of lt. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga644579129332f5be6c17ac058f12b7f7"></a><!-- doxytag: member="typerep.h::tr_verify" ref="ga644579129332f5be6c17ac058f12b7f7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tr_verify </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Walks the type information and performs a set of sanity checks. </p>
<p>Currently, the following checks are executed:</p>
<ul>
<li>values of initialized entities must be allocated on the constant IRG</li>
<li>class types: doesn't have NULL members</li>
<li>class types: all overwrites are existent in the super type</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if graph is correct else error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa0f928ed8164834998f8a2fbef6e7947"></a><!-- doxytag: member="typerep.h::type_not_visited" ref="gaa0f928ed8164834998f8a2fbef6e7947" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int type_not_visited </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if the type is not yet visited. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00002.html">Visited Counters</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2dc2f54709325bd2fc70585dbc7e57ca"></a><!-- doxytag: member="typerep.h::type_visited" ref="ga2dc2f54709325bd2fc70585dbc7e57ca" args="(const ir_type *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int type_visited </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00202.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if the type is already visited. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00002.html">Visited Counters</a> </dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">Generated on Tue Mar 6 2012 16:43:28 for libFirm by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
