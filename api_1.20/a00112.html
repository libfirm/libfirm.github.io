<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libFirm: Callgraph</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libFirm&#160;<span id="projectnumber">1.20</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00112.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Callgraph</div>  </div>
<div class="ingroups"><a class="el" href="a00116.html">Analyses</a></div></div>
<div class="contents">

<p>This file contains the representation of the callgraph.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga4cd6046d0e976598916c3b4411321851">callgraph_walk_func</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *g, void *env)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A function type for functions passed to the callgraph walker.  <a href="#ga4cd6046d0e976598916c3b4411321851"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga13b5fc6be7e13d5a9b4c1d1d500ff520">irp_callgraph_state</a> { <a class="el" href="a00112.html#gga13b5fc6be7e13d5a9b4c1d1d500ff520a8543b62fbb7e27bb42cf12f1bb26f623">irp_callgraph_none</a>, 
<a class="el" href="a00112.html#gga13b5fc6be7e13d5a9b4c1d1d500ff520ab999c48c58183dc70cdf239a816b73e9">irp_callgraph_consistent</a>, 
<a class="el" href="a00112.html#gga13b5fc6be7e13d5a9b4c1d1d500ff520a81aa043f56a812b86850796331e01f26">irp_callgraph_inconsistent</a>, 
<a class="el" href="a00112.html#gga13b5fc6be7e13d5a9b4c1d1d500ff520a399a5d8ad0c34b8d06869c649747cb5c">irp_callgraph_and_calltree_consistent</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate state of callgraph.  <a href="a00112.html#ga13b5fc6be7e13d5a9b4c1d1d500ff520">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga4eb55738a7155de90a67743b83f5031e">loop_nesting_depth_state</a> { <a class="el" href="a00112.html#gga4eb55738a7155de90a67743b83f5031ea61ea14b7de0521c897b00c64ee9b8e6e">loop_nesting_depth_none</a>, 
<a class="el" href="a00112.html#gga4eb55738a7155de90a67743b83f5031ea396f8f2aacd2ebd3db86b22e177e33fc">loop_nesting_depth_consistent</a>, 
<a class="el" href="a00112.html#gga4eb55738a7155de90a67743b83f5031eae5d475dbcd4be31afb81459ec9dc4ecf">loop_nesting_depth_inconsistent</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The state of loop nesting depth.  <a href="a00112.html#ga4eb55738a7155de90a67743b83f5031e">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00112.html#ga13b5fc6be7e13d5a9b4c1d1d500ff520">irp_callgraph_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga5968b0cacd42486f2d3603d5a92807be">get_irp_callgraph_state</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the callgraph state of the program representation.  <a href="#ga5968b0cacd42486f2d3603d5a92807be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#gaed42b73735e60ad00372b4fe3f05ccf0">set_irp_callgraph_state</a> (<a class="el" href="a00112.html#ga13b5fc6be7e13d5a9b4c1d1d500ff520">irp_callgraph_state</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callgraph state of the program representation.  <a href="#gaed42b73735e60ad00372b4fe3f05ccf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga602cb8c5988e90e4cef8c0d3c0b62b21">get_irg_n_callers</a> (const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of procedures that call the given irg.  <a href="#ga602cb8c5988e90e4cef8c0d3c0b62b21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga802e5abbab47479bf177e79b6f496904">get_irg_caller</a> (const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg, size_t pos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the caller at position pos.  <a href="#ga802e5abbab47479bf177e79b6f496904"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga26768b16dba7e133d87b71f76b09bee1">is_irg_caller_backedge</a> (const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg, size_t pos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the caller at position pos is "a backedge", i.e.  <a href="#ga26768b16dba7e133d87b71f76b09bee1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga47ca2e06c2909e840ba454805d54a0a3">has_irg_caller_backedge</a> (const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the irg has a backedge caller.  <a href="#ga47ca2e06c2909e840ba454805d54a0a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga1d503251e6fee5d54221439010464490">get_irg_caller_loop_depth</a> (const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg, size_t pos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal loop depth of call nodes that call along this edge.  <a href="#ga1d503251e6fee5d54221439010464490"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#gab2a261e4051d1c9ad5465f31013d3b3f">get_irg_n_callees</a> (const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of procedures that are called by the given irg.  <a href="#gab2a261e4051d1c9ad5465f31013d3b3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga9010ff099370f5cef420d9373bd63607">get_irg_callee</a> (const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg, size_t pos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the callee at position pos.  <a href="#ga9010ff099370f5cef420d9373bd63607"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#gab35b340ab37d8bc5fdeb2b8d6a2a9a1d">is_irg_callee_backedge</a> (const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg, size_t pos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the callee at position pos is "a backedge", i.e.  <a href="#gab35b340ab37d8bc5fdeb2b8d6a2a9a1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga78f07292179526db3c19c8fb90d253f2">has_irg_callee_backedge</a> (const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the irg has a backedge callee.  <a href="#ga78f07292179526db3c19c8fb90d253f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#gaedf82555ae9a49f721e29ed3e96773d4">get_irg_callee_loop_depth</a> (const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg, size_t pos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal loop depth of call nodes that call along this edge.  <a href="#gaedf82555ae9a49f721e29ed3e96773d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga7585b1435f0fec09ed7bb3467017c755">get_irg_loop_depth</a> (const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal loop depth of all paths from an external visible method to this irg.  <a href="#ga7585b1435f0fec09ed7bb3467017c755"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#gad5fb2dabd816c8bfc33e46fa07c27f85">get_irg_recursion_depth</a> (const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal recursion depth of all paths from an external visible method to this irg.  <a href="#gad5fb2dabd816c8bfc33e46fa07c27f85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#gab0723a0ef8d3c34238279802d1038815">get_irg_method_execution_frequency</a> (const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the method execution frequency of a graph.  <a href="#gab0723a0ef8d3c34238279802d1038815"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#gad6977369d90a149e9e2b6c779a7d3d0e">compute_callgraph</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the callgraph.  <a href="#gad6977369d90a149e9e2b6c779a7d3d0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga4aa63c6933342176f626e96cb3d78bd3">free_callgraph</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the callgraph.  <a href="#ga4aa63c6933342176f626e96cb3d78bd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#gaf767eb6c94e3252573fad8bd30035189">callgraph_walk</a> (<a class="el" href="a00112.html#ga4cd6046d0e976598916c3b4411321851">callgraph_walk_func</a> *pre, <a class="el" href="a00112.html#ga4cd6046d0e976598916c3b4411321851">callgraph_walk_func</a> *post, void *env)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Walks over the callgraph.  <a href="#gaf767eb6c94e3252573fad8bd30035189"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga8bafbdfc32e884141dc81c980472e6f8">find_callgraph_recursions</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the backedges that represent recursions and a looptree.  <a href="#ga8bafbdfc32e884141dc81c980472e6f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga3221f65d7a81a11734ad678903225d18">analyse_loop_nesting_depth</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the interprocedural loop nesting information.  <a href="#ga3221f65d7a81a11734ad678903225d18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00112.html#ga4eb55738a7155de90a67743b83f5031e">loop_nesting_depth_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga674875d6f0dc4370b56f60100d6aa7b3">get_irp_loop_nesting_depth_state</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nesting depth state of the program representation.  <a href="#ga674875d6f0dc4370b56f60100d6aa7b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#gab2cb7e084de99a7bbe7a7b7e71ecac8f">set_irp_loop_nesting_depth_state</a> (<a class="el" href="a00112.html#ga4eb55738a7155de90a67743b83f5031e">loop_nesting_depth_state</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the nesting depth state of the program representation.  <a href="#gab2cb7e084de99a7bbe7a7b7e71ecac8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga75d84a165583aad03aa0166315969431">set_irp_loop_nesting_depth_state_inconsistent</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the nesting depth state of the program representation as inconsistent.  <a href="#ga75d84a165583aad03aa0166315969431"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga12e4393ce267b33e94c73dbe9a00f9ff">cgana</a> (<a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> ***free_methods)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyses a rough estimation of the possible call graph.  <a href="#ga12e4393ce267b33e94c73dbe9a00f9ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga25053e861599c6cb014d058eeac11cf5">free_callee_info</a> (<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *irg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees callee information.  <a href="#ga25053e861599c6cb014d058eeac11cf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#ga9cbef9a6e45816d5006a464abfdc8c1a">free_irp_callee_info</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees callee information for all graphs in the current program.  <a href="#ga9cbef9a6e45816d5006a464abfdc8c1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html#gadeeeb69e28cbba16b1d8861187cb3878">opt_call_addrs</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizes the address expressions passed to call nodes.  <a href="#gadeeeb69e28cbba16b1d8861187cb3878"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>This file contains the representation of the callgraph. </p>
<p>The nodes of the call graph are ir_graphs. The edges between the nodes are calling relations. I.e., if method a calls method b at some point, there is an edge between a and b.</p>
<p>Further this file contains an algorithm to construct the call graph. The construction of the callgraph uses the callee information in Call nodes to determine which methods are called.</p>
<p>Finally this file contains an algorithm that computes backedges in the callgraph, i.e., the algorithm finds possibly recursive calls. The algorithm computes an upper bound of all recursive calls. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga4cd6046d0e976598916c3b4411321851"></a><!-- doxytag: member="callgraph.h::callgraph_walk_func" ref="ga4cd6046d0e976598916c3b4411321851" args="(ir_graph *g, void *env)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="a00112.html#ga4cd6046d0e976598916c3b4411321851">callgraph_walk_func</a>(<a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *g, void *env)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A function type for functions passed to the callgraph walker. </p>

<p>Definition at line <a class="el" href="a00047_source.html#l00119">119</a> of file <a class="el" href="a00047_source.html">callgraph.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga13b5fc6be7e13d5a9b4c1d1d500ff520"></a><!-- doxytag: member="callgraph.h::irp_callgraph_state" ref="ga13b5fc6be7e13d5a9b4c1d1d500ff520" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00112.html#ga13b5fc6be7e13d5a9b4c1d1d500ff520">irp_callgraph_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to indicate state of callgraph. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga13b5fc6be7e13d5a9b4c1d1d500ff520a8543b62fbb7e27bb42cf12f1bb26f623"></a><!-- doxytag: member="irp_callgraph_none" ref="gga13b5fc6be7e13d5a9b4c1d1d500ff520a8543b62fbb7e27bb42cf12f1bb26f623" args="" -->irp_callgraph_none</em>&nbsp;</td><td>
<p>No callgraph allocated. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga13b5fc6be7e13d5a9b4c1d1d500ff520ab999c48c58183dc70cdf239a816b73e9"></a><!-- doxytag: member="irp_callgraph_consistent" ref="gga13b5fc6be7e13d5a9b4c1d1d500ff520ab999c48c58183dc70cdf239a816b73e9" args="" -->irp_callgraph_consistent</em>&nbsp;</td><td>
<p>Callgraph constistent but calltree is inconsistent. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga13b5fc6be7e13d5a9b4c1d1d500ff520a81aa043f56a812b86850796331e01f26"></a><!-- doxytag: member="irp_callgraph_inconsistent" ref="gga13b5fc6be7e13d5a9b4c1d1d500ff520a81aa043f56a812b86850796331e01f26" args="" -->irp_callgraph_inconsistent</em>&nbsp;</td><td>
<p>Callgraph is allocated but inconsistent. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga13b5fc6be7e13d5a9b4c1d1d500ff520a399a5d8ad0c34b8d06869c649747cb5c"></a><!-- doxytag: member="irp_callgraph_and_calltree_consistent" ref="gga13b5fc6be7e13d5a9b4c1d1d500ff520a399a5d8ad0c34b8d06869c649747cb5c" args="" -->irp_callgraph_and_calltree_consistent</em>&nbsp;</td><td>
<p>Both callgraph and calltree are consistent. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00047_source.html#l00053">53</a> of file <a class="el" href="a00047_source.html">callgraph.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4eb55738a7155de90a67743b83f5031e"></a><!-- doxytag: member="callgraph.h::loop_nesting_depth_state" ref="ga4eb55738a7155de90a67743b83f5031e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00112.html#ga4eb55738a7155de90a67743b83f5031e">loop_nesting_depth_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The state of loop nesting depth. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga4eb55738a7155de90a67743b83f5031ea61ea14b7de0521c897b00c64ee9b8e6e"></a><!-- doxytag: member="loop_nesting_depth_none" ref="gga4eb55738a7155de90a67743b83f5031ea61ea14b7de0521c897b00c64ee9b8e6e" args="" -->loop_nesting_depth_none</em>&nbsp;</td><td>
<p>Loop nesting depths are not computed, no memory is allocated, access fails. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga4eb55738a7155de90a67743b83f5031ea396f8f2aacd2ebd3db86b22e177e33fc"></a><!-- doxytag: member="loop_nesting_depth_consistent" ref="gga4eb55738a7155de90a67743b83f5031ea396f8f2aacd2ebd3db86b22e177e33fc" args="" -->loop_nesting_depth_consistent</em>&nbsp;</td><td>
<p>Loop nesting depth information is computed and correct. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga4eb55738a7155de90a67743b83f5031eae5d475dbcd4be31afb81459ec9dc4ecf"></a><!-- doxytag: member="loop_nesting_depth_inconsistent" ref="gga4eb55738a7155de90a67743b83f5031eae5d475dbcd4be31afb81459ec9dc4ecf" args="" -->loop_nesting_depth_inconsistent</em>&nbsp;</td><td>
<p>Loop nesting depth is computed but the graphs have been changed since. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00047_source.html#l00157">157</a> of file <a class="el" href="a00047_source.html">callgraph.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga3221f65d7a81a11734ad678903225d18"></a><!-- doxytag: member="callgraph.h::analyse_loop_nesting_depth" ref="ga3221f65d7a81a11734ad678903225d18" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void analyse_loop_nesting_depth </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the interprocedural loop nesting information. </p>
<p>Computes two numbers for each irg: the depth it is called in 'normal' loops and the depth of recursions it is in.</p>
<p>Computes callee info and the callgraph if this information is not available.</p>
<p>Expects the main irg is set, see <a class="el" href="a00140.html#ga9bef5e6bed181a87a77877da47250f9d" title="Sets the main routine of the compiled program.">set_irp_main_irg()</a>; </p>

</div>
</div>
<a class="anchor" id="gaf767eb6c94e3252573fad8bd30035189"></a><!-- doxytag: member="callgraph.h::callgraph_walk" ref="gaf767eb6c94e3252573fad8bd30035189" args="(callgraph_walk_func *pre, callgraph_walk_func *post, void *env)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void callgraph_walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00112.html#ga4cd6046d0e976598916c3b4411321851">callgraph_walk_func</a> *&#160;</td>
          <td class="paramname"><em>pre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00112.html#ga4cd6046d0e976598916c3b4411321851">callgraph_walk_func</a> *&#160;</td>
          <td class="paramname"><em>post</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Walks over the callgraph. </p>
<p>Walks over the callgraph, starting at the irp main graph. Visits ALL graphs in the irp, even if not reached by the main irg, but for those the call order is not guaranteed.</p>
<p>Executes pre before visiting the predecessor of a node, post after. The void* env can be used to pass status information between the pre and post functions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pre</td><td>- walker function, executed before the predecessor of a node are visited </td></tr>
    <tr><td class="paramname">post</td><td>- walker function, executed after the predecessor of a node are visited </td></tr>
    <tr><td class="paramname">env</td><td>- environment, passed to pre and post </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga12e4393ce267b33e94c73dbe9a00f9ff"></a><!-- doxytag: member="cgana.h::cgana" ref="ga12e4393ce267b33e94c73dbe9a00f9ff" args="(ir_entity ***free_methods)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cgana </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00004.html#ga432640a14055ee444ef07800073673de">ir_entity</a> ***&#160;</td>
          <td class="paramname"><em>free_methods</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Analyses a rough estimation of the possible call graph. </p>
<p>Determines for each Call node the set of possibly called methods. Stores the result in the field 'callees' of the Call node. If the address can not be analysed, e.g. because it is loaded from a variable, the array contains the unknown_entity. (See set_Call_callee()). <a class="el" href="a00112.html#ga12e4393ce267b33e94c73dbe9a00f9ff" title="Analyses a rough estimation of the possible call graph.">cgana()</a> returns the set of 'free' methods, i.e., the methods that can be called from external or via function pointers. This datastructure must be freed with 'xfree()' by the caller of <a class="el" href="a00112.html#ga12e4393ce267b33e94c73dbe9a00f9ff" title="Analyses a rough estimation of the possible call graph.">cgana()</a>.</p>
<p><a class="el" href="a00112.html#ga12e4393ce267b33e94c73dbe9a00f9ff" title="Analyses a rough estimation of the possible call graph.">cgana()</a> sets the callee_info_state of each graph and the program to consistent.</p>
<p>The algorithm implements roughly Static Class Hierarchy Analysis as described in "Optimization of Object-Oriented Programs Using
  Static Class Hierarchy Analysis" by Jeffrey Dean and David Grove and Craig Chambers.</p>
<p>Performs some optimizations possible by the analysed information:</p>
<ul>
<li>Replace SymConst-name nodes by SymConst-entity nodes if possible.</li>
<li>Replace (Sel-method(Alloc)) by SymConst-entity.</li>
<li>Replaces Sel-method by SymConst-entity if the method is never overwritten. </li>
</ul>

</div>
</div>
<a class="anchor" id="gad6977369d90a149e9e2b6c779a7d3d0e"></a><!-- doxytag: member="callgraph.h::compute_callgraph" ref="gad6977369d90a149e9e2b6c779a7d3d0e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_callgraph </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the callgraph. </p>
<p>Expects callee information, i.e., irg_callee_info_consistent must be set. This can be computed with <a class="el" href="a00112.html#ga12e4393ce267b33e94c73dbe9a00f9ff" title="Analyses a rough estimation of the possible call graph.">cgana()</a>. </p>

</div>
</div>
<a class="anchor" id="ga8bafbdfc32e884141dc81c980472e6f8"></a><!-- doxytag: member="callgraph.h::find_callgraph_recursions" ref="ga8bafbdfc32e884141dc81c980472e6f8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void find_callgraph_recursions </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the backedges that represent recursions and a looptree. </p>

</div>
</div>
<a class="anchor" id="ga25053e861599c6cb014d058eeac11cf5"></a><!-- doxytag: member="cgana.h::free_callee_info" ref="ga25053e861599c6cb014d058eeac11cf5" args="(ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_callee_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees callee information. </p>
<p>Sets callee_info_state of the graph passed to none. Sets callee field in all call nodes to NULL. Else it happens that the field contains pointers to other than firm arrays. </p>

</div>
</div>
<a class="anchor" id="ga4aa63c6933342176f626e96cb3d78bd3"></a><!-- doxytag: member="callgraph.h::free_callgraph" ref="ga4aa63c6933342176f626e96cb3d78bd3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_callgraph </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destruct the callgraph. </p>

</div>
</div>
<a class="anchor" id="ga9cbef9a6e45816d5006a464abfdc8c1a"></a><!-- doxytag: member="cgana.h::free_irp_callee_info" ref="ga9cbef9a6e45816d5006a464abfdc8c1a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_irp_callee_info </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees callee information for all graphs in the current program. </p>

</div>
</div>
<a class="anchor" id="ga9010ff099370f5cef420d9373bd63607"></a><!-- doxytag: member="callgraph.h::get_irg_callee" ref="ga9010ff099370f5cef420d9373bd63607" args="(const ir_graph *irg, size_t pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a>* get_irg_callee </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the callee at position pos. </p>

</div>
</div>
<a class="anchor" id="gaedf82555ae9a49f721e29ed3e96773d4"></a><!-- doxytag: member="callgraph.h::get_irg_callee_loop_depth" ref="gaedf82555ae9a49f721e29ed3e96773d4" args="(const ir_graph *irg, size_t pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t get_irg_callee_loop_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the maximal loop depth of call nodes that call along this edge. </p>

</div>
</div>
<a class="anchor" id="ga802e5abbab47479bf177e79b6f496904"></a><!-- doxytag: member="callgraph.h::get_irg_caller" ref="ga802e5abbab47479bf177e79b6f496904" args="(const ir_graph *irg, size_t pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a>* get_irg_caller </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the caller at position pos. </p>

</div>
</div>
<a class="anchor" id="ga1d503251e6fee5d54221439010464490"></a><!-- doxytag: member="callgraph.h::get_irg_caller_loop_depth" ref="ga1d503251e6fee5d54221439010464490" args="(const ir_graph *irg, size_t pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t get_irg_caller_loop_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the maximal loop depth of call nodes that call along this edge. </p>

</div>
</div>
<a class="anchor" id="ga7585b1435f0fec09ed7bb3467017c755"></a><!-- doxytag: member="callgraph.h::get_irg_loop_depth" ref="ga7585b1435f0fec09ed7bb3467017c755" args="(const ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t get_irg_loop_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the maximal loop depth of all paths from an external visible method to this irg. </p>

</div>
</div>
<a class="anchor" id="gab0723a0ef8d3c34238279802d1038815"></a><!-- doxytag: member="callgraph.h::get_irg_method_execution_frequency" ref="gab0723a0ef8d3c34238279802d1038815" args="(const ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_irg_method_execution_frequency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the method execution frequency of a graph. </p>

</div>
</div>
<a class="anchor" id="gab2a261e4051d1c9ad5465f31013d3b3f"></a><!-- doxytag: member="callgraph.h::get_irg_n_callees" ref="gab2a261e4051d1c9ad5465f31013d3b3f" args="(const ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t get_irg_n_callees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of procedures that are called by the given irg. </p>

</div>
</div>
<a class="anchor" id="ga602cb8c5988e90e4cef8c0d3c0b62b21"></a><!-- doxytag: member="callgraph.h::get_irg_n_callers" ref="ga602cb8c5988e90e4cef8c0d3c0b62b21" args="(const ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t get_irg_n_callers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of procedures that call the given irg. </p>

</div>
</div>
<a class="anchor" id="gad5fb2dabd816c8bfc33e46fa07c27f85"></a><!-- doxytag: member="callgraph.h::get_irg_recursion_depth" ref="gad5fb2dabd816c8bfc33e46fa07c27f85" args="(const ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t get_irg_recursion_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the maximal recursion depth of all paths from an external visible method to this irg. </p>

</div>
</div>
<a class="anchor" id="ga5968b0cacd42486f2d3603d5a92807be"></a><!-- doxytag: member="callgraph.h::get_irp_callgraph_state" ref="ga5968b0cacd42486f2d3603d5a92807be" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00112.html#ga13b5fc6be7e13d5a9b4c1d1d500ff520">irp_callgraph_state</a> get_irp_callgraph_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the callgraph state of the program representation. </p>

</div>
</div>
<a class="anchor" id="ga674875d6f0dc4370b56f60100d6aa7b3"></a><!-- doxytag: member="callgraph.h::get_irp_loop_nesting_depth_state" ref="ga674875d6f0dc4370b56f60100d6aa7b3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00112.html#ga4eb55738a7155de90a67743b83f5031e">loop_nesting_depth_state</a> get_irp_loop_nesting_depth_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the nesting depth state of the program representation. </p>

</div>
</div>
<a class="anchor" id="ga78f07292179526db3c19c8fb90d253f2"></a><!-- doxytag: member="callgraph.h::has_irg_callee_backedge" ref="ga78f07292179526db3c19c8fb90d253f2" args="(const ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int has_irg_callee_backedge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if the irg has a backedge callee. </p>

</div>
</div>
<a class="anchor" id="ga47ca2e06c2909e840ba454805d54a0a3"></a><!-- doxytag: member="callgraph.h::has_irg_caller_backedge" ref="ga47ca2e06c2909e840ba454805d54a0a3" args="(const ir_graph *irg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int has_irg_caller_backedge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if the irg has a backedge caller. </p>

</div>
</div>
<a class="anchor" id="gab35b340ab37d8bc5fdeb2b8d6a2a9a1d"></a><!-- doxytag: member="callgraph.h::is_irg_callee_backedge" ref="gab35b340ab37d8bc5fdeb2b8d6a2a9a1d" args="(const ir_graph *irg, size_t pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_irg_callee_backedge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if the callee at position pos is "a backedge", i.e. </p>
<p>a recursion. </p>

</div>
</div>
<a class="anchor" id="ga26768b16dba7e133d87b71f76b09bee1"></a><!-- doxytag: member="callgraph.h::is_irg_caller_backedge" ref="ga26768b16dba7e133d87b71f76b09bee1" args="(const ir_graph *irg, size_t pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_irg_caller_backedge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00129.html#gaf6a2a1e9e04e7719667f8b5945ecdd24">ir_graph</a> *&#160;</td>
          <td class="paramname"><em>irg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if the caller at position pos is "a backedge", i.e. </p>
<p>a recursion. </p>

</div>
</div>
<a class="anchor" id="gadeeeb69e28cbba16b1d8861187cb3878"></a><!-- doxytag: member="cgana.h::opt_call_addrs" ref="gadeeeb69e28cbba16b1d8861187cb3878" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opt_call_addrs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optimizes the address expressions passed to call nodes. </p>
<p>Performs only the optimizations done by cgana. </p>

</div>
</div>
<a class="anchor" id="gaed42b73735e60ad00372b4fe3f05ccf0"></a><!-- doxytag: member="callgraph.h::set_irp_callgraph_state" ref="gaed42b73735e60ad00372b4fe3f05ccf0" args="(irp_callgraph_state s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_irp_callgraph_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00112.html#ga13b5fc6be7e13d5a9b4c1d1d500ff520">irp_callgraph_state</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the callgraph state of the program representation. </p>

</div>
</div>
<a class="anchor" id="gab2cb7e084de99a7bbe7a7b7e71ecac8f"></a><!-- doxytag: member="callgraph.h::set_irp_loop_nesting_depth_state" ref="gab2cb7e084de99a7bbe7a7b7e71ecac8f" args="(loop_nesting_depth_state s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_irp_loop_nesting_depth_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00112.html#ga4eb55738a7155de90a67743b83f5031e">loop_nesting_depth_state</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the nesting depth state of the program representation. </p>

</div>
</div>
<a class="anchor" id="ga75d84a165583aad03aa0166315969431"></a><!-- doxytag: member="callgraph.h::set_irp_loop_nesting_depth_state_inconsistent" ref="ga75d84a165583aad03aa0166315969431" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_irp_loop_nesting_depth_state_inconsistent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks the nesting depth state of the program representation as inconsistent. </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">Generated on Tue Mar 6 2012 16:43:27 for libFirm by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
